<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>OpenMP / OpenBLAS 线程管理策略总结</title>
    <link href="/hpc/cpu/omp-blas-thread-management.html"/>
    <url>/hpc/cpu/omp-blas-thread-management.html</url>
    
    <content type="html"><![CDATA[<p>本文总结了 OpenMP (libgomp) 和 OpenBLAS 两个库的线程管理机制，包括线程池创建、生命周期、环境变量控制以及它们之间的交互关系。</p><div class="note note-success">            <p>代码库和测试详见：<a href="https://github.com/tianyuxbear/omp-blas-thread-lab">https://github.com/tianyuxbear/omp-blas-thread-lab</a></p>           </div><h1 id="1-核心概念区分"><a href="#1-核心概念区分" class="headerlink" title="1. 核心概念区分"></a>1. 核心概念区分</h1><h2 id="1-1-物理核心-vs-逻辑核心"><a href="#1-1-物理核心-vs-逻辑核心" class="headerlink" title="1.1 物理核心 vs 逻辑核心"></a>1.1 物理核心 vs 逻辑核心</h2><ul><li>物理核心 (Physical Cores): 实际的 CPU 计算单元</li><li>逻辑核心 (Logical Cores):  操作系统看到的核心数 </li><li>启用超线程 (Hyper-Threading) 时:<ul><li>逻辑核心 &#x3D; 物理核心 × 2</li><li>例: 24 物理核心 + HT &#x279C; 48 逻辑核心</li></ul></li></ul><p><strong>对 GEMM 等计算密集型任务的影响：</strong></p><ul><li>超线程的两个逻辑核心共享同一物理核心的 L1&#x2F;L2 Cache 和 FMA 单元</li><li>使用 48 线程（逻辑核心数）可能比 24 线程（物理核心数）更慢</li><li><strong>建议：</strong> GEMM 类任务使用物理核心数</li></ul><h2 id="1-2-并行-vs-并发"><a href="#1-2-并行-vs-并发" class="headerlink" title="1.2 并行 vs 并发"></a>1.2 并行 vs 并发</h2><p><strong>线程数 ≤ 核心数:  并行 (Parallel)</strong></p><ul><li>每个线程独占一个核心</li><li>真正的同时执行</li></ul><p><strong>线程数 &gt; 核心数:  并发 (Concurrent)</strong></p><ul><li>线程共享核心，时间片轮转</li><li>有上下文切换开销</li><li>性能可能下降</li></ul><h1 id="2-OpenMP-libgomp-线程管理"><a href="#2-OpenMP-libgomp-线程管理" class="headerlink" title="2. OpenMP (libgomp) 线程管理"></a>2. OpenMP (libgomp) 线程管理</h1><h2 id="2-1-线程模型：按需创建-销毁"><a href="#2-1-线程模型：按需创建-销毁" class="headerlink" title="2.1 线程模型：按需创建&#x2F;销毁"></a>2.1 线程模型：按需创建&#x2F;销毁</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">【OpenMP 线程模型：动态 Fork-Join 视图】<br><br>时间轴 (↓)<br>  │<br>  │ [ 串行区 ] (只有主线程)<br>  │ 主线程 T0 🟢<br>  │<br>  ▼<br>┌────────────────── FORK (分叉) ──────────────────┐<br>│指令: #pragma omp parallel num_threads(24)       │<br>│动作: 主线程创建/唤醒 23 个工作线程              │<br>└─────────────────────────────────────────────────┘<br>  │<br>  │ 并行区 1 (共24线程)<br>  ├─── T0 🟢 (主) ──→ [ 执行任务 ] ──┐<br>  ├─── T1 🟠 (工) ──→ [ 执行任务 ] ──┤<br>  ├─── T2 🟠 (工) ──→ [ 执行任务 ] ──┤<br>  │    . . . (省略 T3-T22) . . .     │<br>  └─── T23🟠 (工) ──→ [ 执行任务 ] ──┘<br>  │<br>  ▼<br>┌────────────────── JOIN (合并) ──────────────────┐<br>│动作: 遇到隐式屏障，等待所有线程完成。           │<br>│      工作线程 T1-T23 被销毁 (概念上)。          │<br>└─────────────────────────────────────────────────┘<br>  │<br>  │ [ 串行区 ] (只有主线程)<br>  │ 主线程 T0 🟢<br>  │<br>  ▼<br>┌────────────────── FORK (分叉) ──────────────────┐<br>│指令: #pragma omp parallel num_threads(4)        │<br>│动作: 主线程创建/唤醒 3 个工作线程               │<br>└─────────────────────────────────────────────────┘<br>  │<br>  │ 并行区 2 (共4线程 - 宽度变窄)<br>  ├─── T0 🟢 (主) ──→ [ 执行任务 ] ──┐<br>  ├─── T1 🟠 (工) ──→ [ 执行任务 ] ──┤<br>  ├─── T2 🟠 (工) ──→ [ 执行任务 ] ──┤<br>  └─── T3 🟠 (工) ──→ [ 执行任务 ] ──┘<br>  │<br>  ▼<br>┌────────────────── JOIN (合并) ──────────────────┐<br>│动作: 屏障同步。工作线程 T1-T3 被销毁。          │<br>└─────────────────────────────────────────────────┘<br>  │<br>  │ [ 串行区 ] (只有主线程)<br>  │ 主线程 T0 🟢<br>  │<br>  ▼<br>┌────────────────── FORK (分叉) ──────────────────┐<br>│指令: #pragma omp parallel num_threads(48)       │<br>│动作: 主线程创建/唤醒 47 个工作线程              │<br>└─────────────────────────────────────────────────┘<br>  │<br>  │ 并行区 3 (共48线程 - 宽度显著增加)<br>  ├─── T0 🟢 (主) ───→ [ 执行任务 ] ──┐<br>  │                                      │<br>  ├─── [ 密集的工作线程组 T1 - T47 ] ────┤ 🟠 (×47)<br>  │    (此处代表大量并行执行的线程)      │<br>  │                                      │<br>  └─── (示意图宽度不足以全画出) ─────────┘<br>  │<br>  ▼<br>┌────────────────── JOIN (合并) ──────────────────┐<br>│动作: 屏障同步。工作线程 T1-T47 被销毁。         │<br>└─────────────────────────────────────────────────┘<br>  │<br>  │ [ 串行区 ] (只有主线程)<br>  │ 主线程 T0 🟢<br>  │<br>  ▼<br>[ 程序结束 ]<br><br>图例:<br>🟢 = 主线程 (Master Thread), 在整个程序生命周期内存在。<br>🟠 = 工作线程 (Worker Threads), 仅在并行区内存在 (逻辑上)。<br></code></pre></td></tr></table></figure><blockquote><p>注：libgomp 的实际实现可能有线程缓存优化，但观测到的行为是按需变化</p></blockquote><h2 id="2-2-关键特性"><a href="#2-2-关键特性" class="headerlink" title="2.2 关键特性"></a>2.2 关键特性</h2><table><thead><tr><th align="left">特性</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">初始化时机</td><td align="left">首次进入 parallel region</td></tr><tr><td align="left">线程数</td><td align="left">每个 region 可以不同</td></tr><tr><td align="left">生命周期</td><td align="left">region 结束后销毁（或缓存复用）</td></tr><tr><td align="left">默认线程数</td><td align="left"><code>omp_get_max_threads()</code></td></tr></tbody></table><h2 id="2-3-API-函数"><a href="#2-3-API-函数" class="headerlink" title="2.3 API 函数"></a>2.3 API 函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 获取当前默认线程数（可配置值，不是硬件限制）</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">omp_get_max_threads</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><br><span class="hljs-comment">// 设置后续 parallel region 的默认线程数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">omp_set_num_threads</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span>;<br><br><span class="hljs-comment">// 获取系统逻辑核心数（硬件信息，固定值）</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">omp_get_num_procs</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><br><span class="hljs-comment">// 在 parallel region 内：获取当前 region 的实际线程数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">omp_get_num_threads</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><br><span class="hljs-comment">// 获取绝对上限（通常是一个很大的数）</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">omp_get_thread_limit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br></code></pre></td></tr></table></figure><h2 id="2-4-线程数控制优先级"><a href="#2-4-线程数控制优先级" class="headerlink" title="2.4 线程数控制优先级"></a>2.4 线程数控制优先级</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">┌──────────────────────────────────────────────────────────────<br>│ OpenMP 线程设置优先级（从高到低 ⬇️）<br>├──────────────────────────────────────────────────────────────<br>│ 🥇 1. #pragma omp parallel num_threads(N)<br>│      ├── 最高优先级，覆盖一切<br>│      ├── 可以超过 omp_get_max_threads()<br>│      └── 可以超过逻辑核心数（变成并发）<br>│<br>│ 🥈 2. omp_set_num_threads(N)<br>│      ├── 运行时修改默认值<br>│      └── 影响后续没有 num_threads 子句的 region<br>│<br>│ 🥉 3. OMP_NUM_THREADS 环境变量<br>│      ├── 程序启动时的初始默认值<br>│      └── 设置 omp_get_max_threads() 的初始值<br>│<br>│ 🔹 4. 实现默认值 (System Default)<br>│      └── 通常等于逻辑核心数<br>└──────────────────────────────────────────────────────────────<br></code></pre></td></tr></table></figure><h2 id="2-5-OMP-NUM-THREADS-不是硬上限"><a href="#2-5-OMP-NUM-THREADS-不是硬上限" class="headerlink" title="2.5 OMP_NUM_THREADS 不是硬上限"></a>2.5 OMP_NUM_THREADS 不是硬上限</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 假设 OMP_NUM_THREADS=8</span><br><br><span class="hljs-built_in">omp_get_max_threads</span>();  <span class="hljs-comment">// → 8 (默认值)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel  <span class="hljs-comment">// 不指定 num_threads</span></span><br>&#123;<br>    <span class="hljs-built_in">omp_get_num_threads</span>();  <span class="hljs-comment">// → 8 (使用默认值)</span><br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel num_threads(24)  <span class="hljs-comment">// 显式指定</span></span><br>&#123;<br>    <span class="hljs-built_in">omp_get_num_threads</span>();  <span class="hljs-comment">// → 24 (可以超过默认值!)</span><br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel num_threads(64)  <span class="hljs-comment">// 超过逻辑核心数</span></span><br>&#123;<br>    <span class="hljs-built_in">omp_get_num_threads</span>();  <span class="hljs-comment">// → 64 (可以! 但是是并发不是并行)</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-OpenBLAS-线程管理"><a href="#3-OpenBLAS-线程管理" class="headerlink" title="3. OpenBLAS 线程管理"></a>3. OpenBLAS 线程管理</h1><h2 id="3-1-线程池模型：固定池"><a href="#3-1-线程池模型：固定池" class="headerlink" title="3.1 线程池模型：固定池"></a>3.1 线程池模型：固定池</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">┌──────────────────────────────────────────────────────────────<br>│ 🚀 OpenBLAS 线程生命周期 (Thread Lifecycle)<br>├──────────────────────────────────────────────────────────────<br>│<br>│ ▶️ 程序启动 (Program Start)<br>│      │<br>│      ▼<br>│ 📦 动态链接器加载 libopenblas.so<br>│      │<br>│      ▼<br>│ ╔══ ⚙️ 初始化阶段 (Constructor Phase) ════════════════════<br>│ ║    (在 main() 之前执行 __attribute__((constructor)))<br>│ ║<br>│ ║  1️⃣ 📖 读取环境变量 OPENBLAS_NUM_THREADS<br>│ ║  2️⃣ 🏊 创建初始大小的线程池 (Thread Pool Created)<br>│ ║  3️⃣ 📈 关键特性: 线程池可扩展，但不再缩小 (Grow Only)<br>│ ╚══════════════════════════════════════════════════════════<br>│      │<br>│      ▼<br>│ 🧊 C++ 静态初始化 (Static Initializers)<br>│      *(注: 此时 OpenBLAS 线程池已存在并就绪)*<br>│      │<br>│      ▼<br>│ 🏁 main() 函数开始执行<br>│<br>└──────────────────────────────────────────────────────────────<br></code></pre></td></tr></table></figure><h2 id="3-2-关键特性"><a href="#3-2-关键特性" class="headerlink" title="3.2 关键特性"></a>3.2 关键特性</h2><table><thead><tr><th align="left">特性</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">初始化时机</td><td align="left">库加载时（constructor），在 <code>main()</code> 之前</td></tr><tr><td align="left">触发条件</td><td align="left">代码中引用了任何 OpenBLAS 符号（延迟绑定）</td></tr><tr><td align="left">初始池大小</td><td align="left">由 <code>OPENBLAS_NUM_THREADS</code> 环境变量决定（默认 &#x3D; 逻辑核心数）</td></tr><tr><td align="left">池大小变化</td><td align="left">只扩展，不缩小（类似 <code>std::vector</code> 的 capacity）</td></tr><tr><td align="left">生命周期</td><td align="left">程序结束时销毁</td></tr></tbody></table><h2 id="3-3-API-函数"><a href="#3-3-API-函数" class="headerlink" title="3.3 API 函数"></a>3.3 API 函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 获取当前&quot;使用&quot;的线程数（不是池大小）</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">openblas_get_num_threads</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><br><span class="hljs-comment">// 设置线程数：</span><br><span class="hljs-comment">//   N &gt; 当前池大小 → 扩展池</span><br><span class="hljs-comment">//   N &lt; 当前池大小 → 只改变使用数，池不缩小</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">openblas_set_num_threads</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span>;<br><br><span class="hljs-comment">// 获取系统逻辑核心数（硬件信息，固定值）</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">openblas_get_num_procs</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><br><span class="hljs-comment">// 获取编译配置信息</span><br><span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">openblas_get_config</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br></code></pre></td></tr></table></figure><h2 id="3-4-线程池行为详解"><a href="#3-4-线程池行为详解" class="headerlink" title="3.4 线程池行为详解"></a>3.4 线程池行为详解</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">┌──────────────────────────────────────────────────────────────────<br>│ 🚀 OPENBLAS_NUM_THREADS=8 启动程序<br>├──────────────────────────────────────────────────────────────────<br>│ 🟩 初始状态:<br>│ 📦 线程池: [T0][T1]...[T7]  ← (共 8 个线程)<br>│ ⚙️ 使用数: 8<br>│<br>├──────────────────────────────────────────────────────────────────<br>│ ▶️ openblas_set_num_threads(24):  📈 请求数 &gt; 池大小 → 扩展！<br>│<br>│ 📦 线程池: [T0][T1]...[T7][T8]...[T23]  ← (扩展到 24 个)<br>│ ⚙️ 使用数: 24<br>│<br>├──────────────────────────────────────────────────────────────────<br>│ ▶️ openblas_set_num_threads(4):   📉 请求数 &lt; 池大小 → 不缩小！<br>│<br>│ 📦 线程池: [T0][T1][T2][T3][💤][💤]...[💤]  (共 24 个仍存活)<br>│            ↑   ↑   ↑   ↑    ↑<br>│           🔥 工作中...     🛌 睡眠中 (20 个)<br>│ ⚙️ 使用数: 4<br>│<br>├──────────────────────────────────────────────────────────────────<br>│ ▶️ openblas_set_num_threads(48):  📈 请求数 &gt; 池大小 → 再次扩展！<br>│<br>│ 📦 线程池: [T0][T1]...[T47]  ← (扩展到 48 个)<br>│ ⚙️ 使用数: 48<br>│<br>├──────────────────────────────────────────────────────────────────<br>│ ▶️ openblas_set_num_threads(4):   📉 请求数 &lt; 池大小 → 不缩小！<br>│<br>│ 📦 线程池: [T0][T1][T2][T3][💤]...[💤]  (共 48 个仍存活)<br>│            ↑   ↑   ↑   ↑    ↑<br>│           🔥 工作中...     🛌 睡眠中 (44 个)<br>│ ⚙️ 使用数: 4<br>│<br>└──────────────────────────────────────────────────────────────────<br></code></pre></td></tr></table></figure><p><strong>总结:</strong></p><ul><li><strong>OPENBLAS_NUM_THREADS</strong> 控制初始池大小</li><li><code>set_num_threads(N)</code> 当 N &gt; 池大小时，扩展池</li><li><code>set_num_threads(N)</code> 当 N &lt; 池大小时，只改变使用数</li><li>池只增不减，类似 <code>std::vector</code> 的 <code>capacity</code></li></ul><h2 id="3-5-环境变量"><a href="#3-5-环境变量" class="headerlink" title="3.5 环境变量"></a>3.5 环境变量</h2><table><thead><tr><th align="left">环境变量</th><th align="left">作用</th><th align="left">优先级</th></tr></thead><tbody><tr><td align="left"><code>OPENBLAS_NUM_THREADS</code></td><td align="left">控制初始线程池大小</td><td align="left">最高</td></tr><tr><td align="left"><code>GOTO_NUM_THREADS</code></td><td align="left">兼容旧版 GotoBLAS</td><td align="left">次之</td></tr><tr><td align="left"><code>OMP_NUM_THREADS</code></td><td align="left">Fallback（部分构建版本）</td><td align="left">较低</td></tr><tr><td align="left">（无）</td><td align="left">使用逻辑核心数</td><td align="left">默认</td></tr></tbody></table><p><strong>注意：</strong> 环境变量只影响初始池大小，运行时 <code>set_num_threads()</code> 可以扩展池。</p><h1 id="4-对比总结"><a href="#4-对比总结" class="headerlink" title="4. 对比总结"></a>4. 对比总结</h1><h2 id="4-1-核心差异"><a href="#4-1-核心差异" class="headerlink" title="4.1 核心差异"></a>4.1 核心差异</h2><table><thead><tr><th align="left">维度</th><th align="left">OpenMP（libgomp）</th><th align="left">OpenBLAS</th></tr></thead><tbody><tr><td align="left">线程模型</td><td align="left">按需创建 &#x2F; 销毁</td><td align="left">可扩展池（只增不减）</td></tr><tr><td align="left">初始化时机</td><td align="left">首次 <code>parallel region</code></td><td align="left">库加载时（<code>main</code> 之前）</td></tr><tr><td align="left">池大小可变</td><td align="left">✅ 每次 region 可不同</td><td align="left">✅ 可扩展，❌ 不缩小</td></tr><tr><td align="left">“池大小” vs “使用数”</td><td align="left">统一</td><td align="left">分离（池 ≥ 使用数）</td></tr><tr><td align="left">空闲线程</td><td align="left">销毁</td><td align="left">睡眠，保持存活</td></tr><tr><td align="left">控制方式</td><td align="left">环境变量 + API + 子句</td><td align="left">环境变量 + <code>set_num_threads()</code></td></tr></tbody></table><h2 id="4-2-get-num-procs-的含义"><a href="#4-2-get-num-procs-的含义" class="headerlink" title="4.2 get_num_procs() 的含义"></a>4.2 <code>get_num_procs()</code> 的含义</h2><p>两个库的 <code>get_num_procs()</code> 含义相同：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">┌──────────────────────────────────────────────────────────────────<br>│ 🖥️  硬件核心数查询 (Hardware Query)<br>│     omp_get_num_procs() / openblas_get_num_procs()<br>├──────────────────────────────────────────────────────────────────<br>│<br>│ 🔢 核心功能:<br>│     └── 返回系统的逻辑核心数 (Logical Core Count)<br>│<br>│ ⚓️ 属性特征:<br>│     └── 属于硬件物理信息，是固定值 (Fixed Value)<br>│<br>│ 🛡️ 独立性:<br>│     └── 坚决不受 OMP_NUM_THREADS 等环境变量影响<br>│<br>│ 🔗 C++ 等价物:<br>│     └── ≈ std::thread::hardware_concurrency()<br>│<br>└──────────────────────────────────────────────────────────────────<br></code></pre></td></tr></table></figure><h1 id="5-环境变量交互"><a href="#5-环境变量交互" class="headerlink" title="5. 环境变量交互"></a>5. 环境变量交互</h1><h2 id="5-1-OpenBLAS-的-Fallback-机制"><a href="#5-1-OpenBLAS-的-Fallback-机制" class="headerlink" title="5.1 OpenBLAS 的 Fallback 机制"></a>5.1 OpenBLAS 的 Fallback 机制</h2><p>部分 OpenBLAS 构建版本在 <code>OPENBLAS_NUM_THREADS</code> 未设置时，会检查其他环境变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">┌──────────────────────────────────────────────────────────────────<br>│ 📉 OpenBLAS 环境变量优先级 (Priority Chain)<br>│    (检查顺序：若上级未设置，则尝试下级)<br>├──────────────────────────────────────────────────────────────────<br>│<br>│ 👑 1. OPENBLAS_NUM_THREADS<br>│      │<br>│      ├── 最高优先级 (Highest Priority)<br>│      └── 专门针对 OpenBLAS 的设置<br>│      │<br>│      ▼<br>│ 🏛️ 2. GOTO_NUM_THREADS<br>│      │<br>│      ├── 历史兼容 (Legacy)<br>│      └── 兼容古老的 GotoBLAS 设置<br>│      │<br>│      ▼<br>│ 🤝 3. OMP_NUM_THREADS<br>│      │<br>│      ├── 通用回退 (Fallback)<br>│      └── 仅在编译时开启 OpenMP 支持时生效<br>│      │<br>│      ▼<br>│ 💻 4. 硬件逻辑核心数 (System Default)<br>│<br>│      ├── 兜底方案 (Baseline)<br>│      └── 如果以上都没设置，占满所有核心<br>│<br>└──────────────────────────────────────────────────────────────────<br></code></pre></td></tr></table></figure><h2 id="5-2-推荐做法"><a href="#5-2-推荐做法" class="headerlink" title="5.2 推荐做法"></a>5.2 推荐做法</h2><p>为避免意外行为，<strong>显式设置两个环境变量：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> OPENBLAS_NUM_THREADS=24<br><span class="hljs-built_in">export</span> OMP_NUM_THREADS=24<br>./program<br></code></pre></td></tr></table></figure><p>或单次运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">OPENBLAS_NUM_THREADS=24 OMP_NUM_THREADS=24 ./program<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>高性能计算</category>
      
      <category>CPU并行编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenMP</tag>
      
      <tag>OpenBLAS</tag>
      
      <tag>HPC</tag>
      
      <tag>多线程</tag>
      
      <tag>并行计算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于 Fluid 的高可用 Hexo 博客实践</title>
    <link href="/tutorials/hexo-fluid-guide.html"/>
    <url>/tutorials/hexo-fluid-guide.html</url>
    
    <content type="html"><![CDATA[<p>谨以此文纪念本站的诞生。<br>本站架构遵循<strong>计算与存储分离</strong>原则：基于 Hexo + Fluid 构建静态资源，源码托管于 GitHub，利用 Cloudflare Pages 与 Vercel 实现多线路全球分发。</p><h1 id="1-核心架构设计"><a href="#1-核心架构设计" class="headerlink" title="1. 核心架构设计"></a>1. 核心架构设计</h1><p>在开始动工前，明确本博客的工程拓扑：</p><ul><li><strong>核心仓库 (hexo-blog)</strong>: 仅包含站点配置 (<code>_config.yml</code>)、文章源码 (<code>source/</code>) 和依赖描述 (<code>package.json</code>)。</li><li><strong>主题管理 (Submodule)</strong>: 将 Fluid 主题作为子模块引入，确保主题更新与个性化配置解耦。</li><li><strong>部署策略 (Edge Computing)</strong>: 放弃传统的 GitHub Pages 直连，利用 Cloudflare 的 Anycast 网络实现毫秒级加载。</li></ul><h1 id="2-环境初始化"><a href="#2-环境初始化" class="headerlink" title="2. 环境初始化"></a>2. 环境初始化</h1><h2 id="基础依赖"><a href="#基础依赖" class="headerlink" title="基础依赖"></a>基础依赖</h2><p>请确保本地开发环境（Windows&#x2F;Mac&#x2F;Linux）已安装以下工具链：</p><ul><li><strong>Git</strong>: 版本控制核心。</li><li><strong>Node.js</strong>: 建议安装 LTS 版本 (推荐 v18+)。</li><li><strong>Hexo CLI</strong>:  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g hexo-cli<br></code></pre></td></tr></table></figure></li></ul><h2 id="仓库构建"><a href="#仓库构建" class="headerlink" title="仓库构建"></a>仓库构建</h2><p>本博客在本地建立项目 <code>Devhub/hexo-blog</code>。为了保持仓库整洁，不直接 clone 整个主题代码，而是采用初始化生成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 初始化脚手架</span><br>hexo init hexo-blog<br><span class="hljs-built_in">cd</span> hexo-blog<br>npm install<br></code></pre></td></tr></table></figure><p>此时目录结构应清晰如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">.<br>├── _config.landscape.yml<br>├── _config.yml      # 站点全局配置<br>├── package.json     # 依赖管理<br>├── scaffolds        # 模板文件<br>│   ├── draft.md<br>│   ├── page.md<br>│   └── post.md<br>├── source           # 博客文章与自定义资源<br>│   └── _posts<br>│       └── hello-world.md<br>└── themes           # 主题目录<br></code></pre></td></tr></table></figure><div class="note note-info">            <p><strong>Git 策略提示</strong> 建议在 <code>.gitignore</code> 中排除 <code>node_modules</code> 和 <code>public</code> 目录。<code>package-lock.json</code> 建议保留以锁定依赖版本，确保多端构建一致性，但如果你追求极致的仓库轻量化，确保 <code>package.json</code> 版本号写死即可。</p>           </div><h1 id="3-主题管理：Fluid-的非侵入式集成"><a href="#3-主题管理：Fluid-的非侵入式集成" class="headerlink" title="3. 主题管理：Fluid 的非侵入式集成"></a>3. 主题管理：Fluid 的非侵入式集成</h1><p>为了解决“直接下载主题包难以更新”和“修改源码导致冲突”的痛点，我们采用 <strong>Git Submodule</strong> 方案。</p><h2 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 移除默认主题（可选）</span><br><span class="hljs-built_in">rm</span> -rf themes/landscape<br><br><span class="hljs-comment"># 将 Fluid 挂载为子模块</span><br>git submodule add https://github.com/fluid-dev/hexo-theme-fluid.git themes/fluid<br></code></pre></td></tr></table></figure><h2 id="配置解耦-Shadow-Config"><a href="#配置解耦-Shadow-Config" class="headerlink" title="配置解耦 (Shadow Config)"></a>配置解耦 (Shadow Config)</h2><p>Fluid 支持“影子配置”模式。我们将主题的配置文件复制到根目录，并重命名为 <code>_config.fluid.yml</code>。Hexo 会优先读取此文件，从而覆盖 <code>themes/fluid/_config.yml</code> 中的默认值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> themes/fluid/_config.yml _config.fluid.yml<br></code></pre></td></tr></table></figure><p>之后所有对主题的修改（导航栏、颜色、功能开关）均在根目录的 <code>_config.fluid.yml</code> 中进行，<strong>永远不要修改 themes&#x2F;fluid 目录下的文件</strong>。</p><h2 id="站点基础配置"><a href="#站点基础配置" class="headerlink" title="站点基础配置"></a>站点基础配置</h2><p>修改 <code>hexo-blog/_config.yml</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Extensions</span><br><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span><br><span class="hljs-attr">timezone:</span> <span class="hljs-string">Asia/Shanghai</span><br><br><span class="hljs-comment"># URL (Cloudflare Pages 提供的域名或自定义域名)</span><br><span class="hljs-attr">url:</span> <span class="hljs-string">https://codebearjourney.top</span><br></code></pre></td></tr></table></figure><h1 id="4-深度定制与美化"><a href="#4-深度定制与美化" class="headerlink" title="4. 深度定制与美化"></a>4. 深度定制与美化</h1><h2 id="Mac-Style-代码高亮"><a href="#Mac-Style-代码高亮" class="headerlink" title="Mac-Style 代码高亮"></a>Mac-Style 代码高亮</h2><p>Fluid 支持自定义 CSS 注入。为了实现类似 Mac 窗口的圆角与红绿灯效果，我们采用<strong>外部注入</strong>的方式。</p><ol><li><strong>配置 Highlight.js：</strong> 在 <code>_config.fluid.yml</code> 中设置：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 实现高亮的库，对应下面的设置</span><br><span class="hljs-comment"># Highlight library</span><br><span class="hljs-comment"># Options: highlightjs | prismjs</span><br><span class="hljs-attr">lib:</span> <span class="hljs-string">&quot;highlightjs&quot;</span><br><br><span class="hljs-attr">highlightjs:</span><br>  <span class="hljs-comment"># 在链接中挑选 style 填入</span><br>  <span class="hljs-comment"># Select a style in the link</span><br>  <span class="hljs-comment"># See: https://highlightjs.org/demo/</span><br>  <span class="hljs-attr">style:</span> <span class="hljs-string">&quot;atom-one-dark&quot;</span><br>  <span class="hljs-attr">style_dark:</span> <span class="hljs-string">&quot;atom-one-dark&quot;</span><br>  <span class="hljs-attr">bg_color:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><ol start="2"><li><strong>创建样式文件：</strong> 新建 <code>source/css/mac.styl</code>，粘贴以下内容：</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-class">.highlight</span><br>    <span class="hljs-attribute">background</span>: <span class="hljs-number">#282C34</span>   <span class="hljs-comment">/* Atom One Dark 背景色 */</span><br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span><br>    <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-number">30px</span> <span class="hljs-number">0</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, .<span class="hljs-number">4</span>)<br>    <span class="hljs-attribute">padding-top</span>: <span class="hljs-number">30px</span><br><br>    <span class="hljs-selector-pseudo">&amp;::before</span><br>      <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27; &#x27;</span><br>      <span class="hljs-attribute">position</span>: absolute<br>      <span class="hljs-attribute">top</span>: <span class="hljs-number">15px</span><br>      <span class="hljs-attribute">left</span>: <span class="hljs-number">15px</span><br>      <span class="hljs-attribute">width</span>: <span class="hljs-number">12px</span><br>      <span class="hljs-attribute">height</span>: <span class="hljs-number">12px</span><br>      <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span><br>      <span class="hljs-attribute">background</span>: <span class="hljs-number">#fc625d</span><br>      <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">20px</span> <span class="hljs-number">0</span> <span class="hljs-number">#fdbc40</span>, <span class="hljs-number">40px</span> <span class="hljs-number">0</span> <span class="hljs-number">#35cd4b</span><br></code></pre></td></tr></table></figure><ol start="3"><li><strong>注入配置：</strong> 在 <code>_config.fluid.yml</code> 中注册：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">custom_css:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">/css/mac.css</span><br></code></pre></td></tr></table></figure><p><em>注意：虽然源文件是 stylus，Hexo 会自动编译为 css，此处引用需写 .css 后缀。</em></p><h2 id="数学公式渲染-LaTeX"><a href="#数学公式渲染-LaTeX" class="headerlink" title="数学公式渲染 (LaTeX)"></a>数学公式渲染 (LaTeX)</h2><p>为了在技术文章中优雅地展示公式，使用 <code>hexo-math</code>。 </p><p>安装<code>hexo-math</code>插件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用 npm 安装 Hexo-math插件</span><br><span class="hljs-comment">## Docs: https://github.com/hexojs/hexo-math</span><br>npm install hexo-math --save<br></code></pre></td></tr></table></figure><p>在站点 <code>_config.yml</code> 中添加：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Hexo-math</span><br><span class="hljs-comment">## Docs: https://github.com/hexojs/hexo-math</span><br><span class="hljs-attr">math:</span><br>  <span class="hljs-attr">katex:</span><br>    <span class="hljs-attr">css:</span> <span class="hljs-string">&#x27;https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css&#x27;</span><br>    <span class="hljs-attr">options:</span><br>      <span class="hljs-attr">throwOnError:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">mathjax:</span><br>    <span class="hljs-attr">css:</span> <span class="hljs-string">&#x27;https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css&#x27;</span><br>    <span class="hljs-attr">options:</span><br>      <span class="hljs-attr">conversion:</span><br>        <span class="hljs-attr">display:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-attr">tex:</span><br>      <span class="hljs-attr">svg:</span><br></code></pre></td></tr></table></figure><p><em>优化建议：默认对所有页面关闭公式渲染（提升加载速度），仅在需要的文章 Front-matter 中开启(参见后文 Front-matter 部分)</em></p><h1 id="5-内容生产流"><a href="#5-内容生产流" class="headerlink" title="5. 内容生产流"></a>5. 内容生产流</h1><h2 id="Front-matter-模板工程化"><a href="#Front-matter-模板工程化" class="headerlink" title="Front-matter 模板工程化"></a>Front-matter 模板工程化</h2><p>修改 <code>scaffolds/post.md</code>，预设常用的元数据，减少重复劳动：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> &#123;&#123; <span class="hljs-string">title</span> &#125;&#125;<br><span class="hljs-attr">date:</span> &#123;&#123; <span class="hljs-string">date</span> &#125;&#125;<br><span class="hljs-attr">updated:</span><br><span class="hljs-attr">index_img:</span><br><span class="hljs-attr">category_bar:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">categories:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">Foo</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">Bar</span><br><span class="hljs-attr">tags:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">Foo</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">Bar</span><br><span class="hljs-attr">katex:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">mathjax:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">excerpt:</span> <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-attr">sticky:</span> <br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br></code></pre></td></tr></table></figure><h2 id="静态资源压缩"><a href="#静态资源压缩" class="headerlink" title="静态资源压缩"></a>静态资源压缩</h2><p>在构建流水线中加入压缩环节，减少传输体积。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用 npm 安装 hexo-all-minifier 插件</span><br><span class="hljs-comment">## Docs: https://github.com/chenzhutian/hexo-all-minifier</span><br>npm install hexo-all-minifier --save<br></code></pre></td></tr></table></figure><p>在 <code>_config.yml</code> 开启:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># All in one. Minifier &amp; Optimization plugin for Hexo.</span><br><span class="hljs-comment">## Docs: https://github.com/chenzhutian/hexo-all-minifier</span><br><span class="hljs-attr">all_minifier:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h1 id="6-高可用部署架构"><a href="#6-高可用部署架构" class="headerlink" title="6. 高可用部署架构"></a>6. 高可用部署架构</h1><p>本站采用 <strong>双线热备</strong> 方案。GitHub 仅作为代码仓库，由 Cloudflare Pages 和 Vercel 负责分发。</p><pre><code class=" mermaid">graph LR    User(用户访问) --&gt; DNS&#123;Cloudflare DNS&#125;    DNS -- &quot;线路优选 (默认)&quot; --&gt; CF[Cloudflare Pages]    DNS -- &quot;故障切换 (备用)&quot; --&gt; Vercel[Vercel]    CF -- &quot;自动拉取&quot; --&gt; GH[(GitHub Repo)]    Vercel -- &quot;自动拉取&quot; --&gt; GH</code></pre><h2 id="6-1-部署到-GitHub-Pages-基础"><a href="#6-1-部署到-GitHub-Pages-基础" class="headerlink" title="6.1 部署到 GitHub Pages (基础)"></a>6.1 部署到 GitHub Pages (基础)</h2><p>这是最经典的部署方式，通过 Git 钩子将生成的静态文件推送到 GitHub 仓库。哪怕后续使用 CDN 加速，保留原始的 GitHub Pages 也是极好的“源站”备份。</p><ol><li><strong>创建仓库：</strong> 在 GitHub 上创建一个名为 <code>tianyuxbear.github.io</code> 的公开仓库。</li><li><strong>安装部署插件：</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用 npm 安装 Github Deploy插件</span><br>npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>配置站点文件：</strong> 修改 <code>_config.yml</code> 中的部署模块：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Deployment</span><br><span class="hljs-comment">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">git@github.com:tianyuxbear/tianyuxbear.github.io.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure><ol start="4"><li><strong>一键部署</strong>： 执行以下组合命令，完成清除缓存、生成静态文件、推送部署：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d<br></code></pre></td></tr></table></figure><h2 id="6-2-部署至-Cloudflare-Pages-核心"><a href="#6-2-部署至-Cloudflare-Pages-核心" class="headerlink" title="6.2 部署至 Cloudflare Pages (核心)"></a>6.2 部署至 Cloudflare Pages (核心)</h2><p>相比 GitHub Pages，Cloudflare 提供国内更友好的 CDN 节点和 HTTP&#x2F;3 支持。</p><ol><li><strong>绑定仓库：</strong> 在 Cloudflare Dashboard 中关联 GitHub 账号，选择 <code>hexo-blog</code> 仓库。</li><li><strong>构建配置：</strong><ul><li>Build Command: 空</li><li>Build Output Directory: 空(默认是&#x2F;)</li></ul></li><li><strong>等待部署：</strong> 点击部署，几分钟后即可通过 <a href="https://tianyuxbear-github-io.pages.dev/">https://tianyuxbear-github-io.pages.dev/</a> 访问。</li></ol><h2 id="6-3-部署至-Vercel-灾备"><a href="#6-3-部署至-Vercel-灾备" class="headerlink" title="6.3 部署至 Vercel (灾备)"></a>6.3 部署至 Vercel (灾备)</h2><p>配置逻辑同上。Vercel 的国内访问速度在部分地区可能优于 Cloudflare，可作为互补。</p><ul><li><strong>Framework Preset:</strong> <code>Other</code>。</li><li><strong>Output Directory:</strong> <code>/</code>。</li></ul><p>部署成功后，即可通过 <a href="https://tianyuxbear-github-io.vercel.app/">https://tianyuxbear-github-io.vercel.app/</a> 访问。</p><h2 id="6-4-自定义域名配置-重要"><a href="#6-4-自定义域名配置-重要" class="headerlink" title="6.4 自定义域名配置 (重要)"></a>6.4 自定义域名配置 (重要)</h2><p>为了获得最佳的访问速度和 HTTPS 支持，我们采用 <strong>DNS 托管模式</strong> 将域名完全接入 Cloudflare。</p><p><strong>第一步：域名注册 (以阿里云为例)</strong></p><ol><li>在阿里云官网购买域名（如 <code>codebearjourney.top</code>）。</li><li>完成实名认证。</li></ol><p><strong>第二步：DNS 迁移至 Cloudflare</strong> 这是加速的关键步骤。将域名的 DNS 解析权交给 Cloudflare，利用其全球 Anycast 网络。</p><ol><li>登录 Cloudflare Dashboard，点击 “Add a Site”，输入你的域名。</li><li>选择 “Free” 计划。</li><li>Cloudflare 会扫描当前的 DNS 记录，确认无误后点击 Continue。</li><li><strong>修改 Nameservers：</strong><ul><li>Cloudflare 会提供两个 Nameserver 地址（如 <code>bob.ns.cloudflare.com</code> 等）。</li><li>回到阿里云域名控制台 -&gt; 域名列表 -&gt; 管理 -&gt; DNS 修改 -&gt; 修改 DNS 服务器。</li><li>将阿里云默认的 DNS 修改为 Cloudflare 提供的这两个地址。</li></ul></li><li>等待生效（通常在 10 分钟到 24 小时内）。</li></ol><p><strong>第三步：绑定 Pages</strong></p><ol><li>在 Cloudflare Pages 项目页面，点击 “Custom domains”。</li><li>输入 <code>codebearjourney.top</code>。</li><li>由于你的 DNS 已经托管在 Cloudflare，系统会自动添加 CNAME 记录并申请 SSL 证书。</li><li>(可选) 同时添加 <code>www.codebearjourney.top</code> 并设置重定向，符合用户习惯。</li></ol><p>通过此配置，访问请求路径为： <code>用户</code> -&gt; <code>Cloudflare 边缘节点 (DNS+CDN)</code> -&gt; <code>Pages 静态资源</code>。</p><h1 id="7-SEO-与收录优化"><a href="#7-SEO-与收录优化" class="headerlink" title="7. SEO 与收录优化"></a>7. SEO 与收录优化</h1><p>为了让 Google 和 Bing 快速索引，我们需要配置 Sitemap 并完成站长验证。</p><h2 id="7-1-生成-Sitemap"><a href="#7-1-生成-Sitemap" class="headerlink" title="7.1 生成 Sitemap"></a>7.1 生成 Sitemap</h2><p>告诉搜索引擎你的网站结构和文章路径。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用 npm 安装 Hexo-sitemap 插件</span><br>npm install hexo-generator-sitemap --save<br></code></pre></td></tr></table></figure><p>在 <code>_config.yml</code> 确认开启：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 确保 sitemap 插件已启用</span><br><span class="hljs-attr">sitemap:</span><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">sitemap.xml</span><br></code></pre></td></tr></table></figure><h2 id="7-2-站长平台验证-DNS-方式"><a href="#7-2-站长平台验证-DNS-方式" class="headerlink" title="7.2 站长平台验证 (DNS 方式)"></a>7.2 站长平台验证 (DNS 方式)</h2><p>传统的验证方式是上传一个 HTML 文件到 <code>public 目录</code>，这会污染源码且容易在重构中丢失。<strong>强烈推荐使用 Cloudflare DNS 进行 TXT 记录验证</strong>，这种方式无代码侵入，且得益于 Cloudflare 的生效速度，通常秒级通过。</p><p><strong>Google Search Console</strong></p><ol><li><strong>获取验证码：</strong><ul><li>登录 <a href="https://search.google.com/search-console">Google Search Console</a>。</li><li>在左上角选择资源类型时，选择 <strong>“网域” (Domain)</strong>（而不是 “网址前缀”）。</li><li>输入你的域名（不带 https，如 <code>codebearjourney.top</code>）。</li><li>系统会弹出一个对话框，复制显示的 <strong>TXT 记录值</strong>（通常以 <code>google-site-verification=</code> 开头）。</li></ul></li><li><strong>Cloudflare 配置：</strong><ul><li><p>登录 Cloudflare Dashboard，进入你的域名页面。</p></li><li><p>点击左侧菜单 <strong>DNS -&gt; Records</strong>。</p></li><li><p>点击 <strong>Add record</strong> 按钮：</p><ul><li><strong>Type:</strong> 选择 <code>TXT</code></li><li><strong>Name:</strong> 输入 <code>@</code> (代表根域名)</li><li><strong>Content:</strong> 粘贴刚才复制的 <code>google-site-verification=...</code> 字符串</li><li><strong>TTL:</strong> 保持 <code>Auto</code></li></ul></li><li><p>点击 <strong>Save</strong>。</p></li></ul></li><li><strong>完成验证：</strong><ul><li>回到 Google Search Console 页面，点击 <strong>验证</strong> 按钮。通常会立即提示“已验证所有权”。</li></ul></li></ol><p><strong>Bing Webmaster Tools</strong><br>微软提供了一个极其高效的“偷懒”路径：</p><ol><li>登录 <a href="https://www.bing.com/webmasters/about">Bing Webmaster Tools</a>。</li><li>选择 “<strong>Import from Google Search Console</strong>“（从 GSC 导入）。</li><li>授权你的 Google 账号，Bing 会自动同步你的站点验证状态和 Sitemap 地址，无需再手动添加 DNS 记录。</li></ol><h2 id="7-3-提交-Sitemap"><a href="#7-3-提交-Sitemap" class="headerlink" title="7.3 提交 Sitemap"></a>7.3 提交 Sitemap</h2><p>验证通过后，别忘了最后一步：</p><ol><li>确认 <code>https://codebearjourney.top/sitemap.xml</code> 可以访问。</li><li>在 Google&#x2F;Bing 后台的 <strong>Sitemaps</strong> 菜单中，填入 <code>sitemap.xml</code> 并提交。</li></ol><h1 id="8-多端同步工作流"><a href="#8-多端同步工作流" class="headerlink" title="8. 多端同步工作流"></a>8. 多端同步工作流</h1><p>由于采用了 Submodule 和标准化的 npm 依赖管理，在新设备上恢复工作流极其简单：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1. 克隆主仓库</span><br>git <span class="hljs-built_in">clone</span> git@github.com:tianyuxbear/hexo-blog.git<br><span class="hljs-built_in">cd</span> hexo-blog<br><br><span class="hljs-comment"># 2. 递归恢复子模块 (还原 fluid 主题)</span><br>git submodule update --init --recursive<br><br><span class="hljs-comment"># 3. 恢复插件依赖 (根据 package.json)</span><br>npm install<br></code></pre></td></tr></table></figure><p>至此，环境完全复刻，可以开始写作了。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://hexo.io/zh-cn/docs/">Hexo官方文档</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://hexo.fluid-dev.com/docs/">Hexo Fluid 用户手册</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://hewei2001.pages.dev/Hello-My-World">Hello My World</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://hewei2001.pages.dev/Hexo-Configuration#%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE">Hexo配置与扩展</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>配置指南</category>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
      <tag>CI/CD</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
