<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>GDB调试: 从入门实践到原理 | codebear</title><meta name=keywords content="GDB,调试,Linux,C++,开发工具"><meta name=description content="全面介绍 GDB 调试器的使用方法，从基础命令到高级技巧，再到底层实现原理"><meta name=author content="Tianyu Xiong"><link rel=canonical href=https://codebearjourney.top/posts/gdb%E8%B0%83%E8%AF%95-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E5%88%B0%E5%8E%9F%E7%90%86/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.fde6446529a94d8c748508e7d316d32f2881be6223a83d1c56fa0bf80e3bc6c1.css integrity="sha256-/eZEZSmpTYx0hQjn0xbTLyiBvmIjqD0cVvoL+A47xsE=" rel="preload stylesheet" as=style><link rel=icon href=https://codebearjourney.top/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://codebearjourney.top/%3C...%3E><link rel=icon type=image/png sizes=32x32 href=https://codebearjourney.top/%3C...%3E><link rel=apple-touch-icon href=https://codebearjourney.top/favicon/apple-touch-icon.png><link rel=mask-icon href=https://codebearjourney.top/%3C...%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://codebearjourney.top/posts/gdb%E8%B0%83%E8%AF%95-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E5%88%B0%E5%8E%9F%E7%90%86/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://codebearjourney.top/posts/gdb%E8%B0%83%E8%AF%95-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E5%88%B0%E5%8E%9F%E7%90%86/"><meta property="og:site_name" content="codebear"><meta property="og:title" content="GDB调试: 从入门实践到原理"><meta property="og:description" content="全面介绍 GDB 调试器的使用方法，从基础命令到高级技巧，再到底层实现原理"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-10-25T21:18:14+08:00"><meta property="article:modified_time" content="2025-10-25T21:18:14+08:00"><meta property="article:tag" content="GDB"><meta property="article:tag" content="调试"><meta property="article:tag" content="Linux"><meta property="article:tag" content="C++"><meta property="article:tag" content="开发工具"><meta property="og:image" content="https://codebearjourney.top/images/peace.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://codebearjourney.top/images/peace.png"><meta name=twitter:title content="GDB调试: 从入门实践到原理"><meta name=twitter:description content="全面介绍 GDB 调试器的使用方法，从基础命令到高级技巧，再到底层实现原理"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://codebearjourney.top/posts/"},{"@type":"ListItem","position":2,"name":"GDB调试: 从入门实践到原理","item":"https://codebearjourney.top/posts/gdb%E8%B0%83%E8%AF%95-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E5%88%B0%E5%8E%9F%E7%90%86/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"GDB调试: 从入门实践到原理","name":"GDB调试: 从入门实践到原理","description":"全面介绍 GDB 调试器的使用方法，从基础命令到高级技巧，再到底层实现原理","keywords":["GDB","调试","Linux","C++","开发工具"],"articleBody":"一直有读者在问，能不能写一篇关于gdb调试方面的文章，今天借助此文，分享一些工作中的调试经验，希望能够帮到大家。\n写在前面 在我的工作经历中，前几年在Windows上进行开发，使用Visual Studio进行调试，简直是利器，各种断点等用鼠标点点点就能设置；大概从12年开始转Linux开发了，所以调试都是基于GDB的。本来这篇文章也想写写Windows下调试相关，奈何好多年没用了，再加上工作太忙，所以本文就只写了Linux下GDB调试相关，对于Windows开发人员，实在对不住了😃。\n这篇文章，涉及的比较全面，总结了这些年的gdb调试经验(都是小儿科😁)，经常用到的一些调试技巧，希望能够对从事Linux开发的相关人员有所帮助\n背景 作为C/C++开发人员，保证程序正常运行是最基本也是最主要的目的。而为了保证程序正常运行，调试则是最基本的手段，熟悉这些调试方式，可以方便我们更快的定位程序问题所在，提高开发效率。\n在开发过程，如果程序的运行结果不符合预期，第一时间就是打开GDB进行调试，在对应的地方设置断点，然后分析原因；当线上服务出了问题，第一时间查看进程在不在，如果不在的话，是否生成了coredump文件，如果有，则使用gdb调试coredump文件，否则通过dmesg来分析内核日志来查找原因。\n概念 GDB是一个由GNU开源组织发布的、UNIX/LINUX操作系统下的、「基于命令行的、功能强大的程序调试工具」。\nGDB支持断点、单步执行、打印变量、观察变量、查看寄存器、查看堆栈等调试手段。在Linux环境软件开发中，GDB是主要的调试工具，用来调试C和 C++程序(也支持go等其他语言)。\n常用命令 断点 断点是我们在调试中经常用的一个功能，我们在指定位置设置断点之后，程序运行到该位置将会暂停，这个时候我们就可以对程序进行更多的操作，比如查看变量内容，堆栈情况等等，以帮助我们调试程序。\n以设置断点的命令分为以下几类：\nbreakpoint\nwatchpoint\ncatchpoint\nbreakpoint 可以根据行号、函数、条件生成断点，下面是相关命令以及对应的作用说明：\n命令作用break [file]:function在文件file的function函数入口设置断点break [file]:line在文件file的第line行设置断点info breakpoints查看断点列表break [+-]offset在当前位置偏移量为[+-]offset处设置断点break *addr在地址addr处设置断点break ... if expr设置条件断点，仅仅在条件满足时ignore n count接下来对于编号为n的断点忽略count次clear删除所有断点clear function删除所有位于function内的断点delete n删除指定编号的断点enable n启用指定编号的断点disable n禁用指定编号的断点save breakpoints file保存断点信息到指定文件source file导入文件中保存的断点信息break在下一个指令处设置断点clear [file:]line删除第line行的断点 watchpoint watchpoint是一种特殊类型的断点，类似于正常断点，是要求GDB暂停程序执行的命令。区别在于watchpoint没有驻留某一行源代码中，而是指示GDB每当某个表达式改变了值就暂停执行的命令。\nwatchpoint分为硬件实现和软件实现两种。前者需要硬件系统的支持；后者的原理就是每步执行后都检查变量的值是否改变。GDB在新建数据断点时会优先尝试硬件方式，如果失败再尝试软件实现。\n命令作用watch variable设置变量数据断点watch var1 + var2设置表达式数据断点rwatch variable设置读断点，仅支持硬件实现awatch variable设置读写断点，仅支持硬件实现info watchpoints查看数据断点列表set can-use-hw-watchpoints 0强制基于软件方式实现 使用数据断点时，需要注意：\n当监控变量为局部变量时，一旦局部变量失效，数据断点也会失效\n如果监控的是指针变量p，则watch *p监控的是p所指内存数据的变化情况，而watch p监控的是p指针本身有没有改变指向\n最常见的数据断点应用场景：「定位堆上的结构体内部成员何时被修改」。由于指针一般为局部变量，为了解决断点失效，一般有两种方法。\n命令作用print \u0026variable查看变量的内存地址watch *(type *)address通过内存地址间接设置断点watch -l variable指定location参数watch variable thread 1仅编号为1的线程修改变量var值时会中断 catchpoint 从字面意思理解，是捕获断点，其主要监测信号的产生。例如c++的throw，或者加载库的时候，产生断点行为。\n命令含义catch fork程序调用fork时中断tcatch fork设置的断点只触发一次，之后被自动删除catch syscall ptrace为ptrace系统调用设置断点 [!tip] Tips 在command命令后加断点编号，可以定义断点触发后想要执行的操作。在一些高级的自动化调试场景中可能会用到。\n命令行 命令作用run arglist以arglist为参数列表运行程序set args arglist指定启动命令行参数set args指定空的参数列表show args打印命令行列表 程序栈 命令作用backtrace [n]打印栈帧frame [n]选择第n个栈帧，如果不存在，则打印当前栈帧up n选择当前栈帧编号+n的栈帧down n选择当前栈帧编号-n的栈帧info frame [addr]描述当前选择的栈帧info args当前栈帧的参数列表info locals当前栈帧的局部变量 多进程、多线程 多进程 GDB在调试多进程程序（程序含fork调用）时，默认只追踪父进程。可以通过命令设置，实现只追踪父进程或子进程，或者同时调试父进程和子进程。\n命令作用info inferiors查看进程列表attach pid绑定进程idinferior num切换到指定进程上进行调试print $_exitcode显示程序退出时的返回值set follow-fork-mode child追踪子进程set follow-fork-mode parent追踪父进程set detach-on-fork onfork调用时只追踪其中一个进程set detach-on-fork offfork调用时会同时追踪父子进程 在调试多进程程序时候，默认情况下，除了当前调试的进程，其他进程都处于挂起状态，所以，如果需要在调试当前进程的时候，其他进程也能正常执行，那么通过设置set schedule-multiple on即可。\n多线程 多线程开发在日常开发工作中很常见，所以多线程的调试技巧非常有必要掌握。\n默认调试多线程时，一旦程序中断，所有线程都将暂停。如果此时再继续执行当前线程，其他线程也会同时执行。\n命令作用info threads查看线程列表print $_thread显示当前正在调试的线程编号set scheduler-locking on调试一个线程时，其他线程暂停执行set scheduler-locking off调试一个线程时，其他线程同步执行set scheduler-locking step仅用step调试线程时其他线程不执行，用其他命令如next调试时仍执行 如果只关心当前线程，建议临时设置scheduler-locking为on，避免其他线程同时运行，导致命中其他断点分散注意力。\n打印输出 通常情况下，在调试的过程中，我们需要查看某个变量的值，以分析其是否符合预期，这个时候就需要打印输出变量值。\n命令作用whatis variable查看变量的类型ptype variable查看变量详细的类型信息info variables var查看定义该变量的文件，不支持局部变量 打印字符串 使用x/s命令打印ASCII字符串，如果是宽字符字符串，需要先看宽字符的长度print sizeof(str)。\n如果长度为2，则使用x/hs打印；如果长度为4，则使用x/ws打印。\n命令作用x/s str打印字符串set print elements 0打印不限制字符串长度/或不限制数组长度call printf(\"%s\\n\",xxx)这时打印出的字符串不会含有多余的转义符printf \"%s\\n\",xxx同上 打印数组 命令作用print *array@10打印从数组开头连续10个元素的值print array[60]@10打印array数组下标从60开始的10个元素，即第60~69个元素set print array-indexes on打印数组元素时，同时打印数组的下标 打印指针 命令作用print ptr查看该指针指向的类型及指针地址print *(struct xxx *)ptr查看指向的结构体的内容 打印指定内存地址的值 使用x命令来打印内存的值，格式为x/nfu addr，以f格式打印从addr开始的n个长度单元为u的内存值。\nn：输出单元的个数\nf：输出格式，如x表示以16进制输出，o表示以8进制输出，默认为x\nu：一个单元的长度，b表示1个byte，h表示2个byte（half word），w表示4个byte ，g表示8个byte（giant word）。\n命令作用x/8xb array以16进制打印数组array的前8个byte的值x/8xw array以16进制打印数组array的前16个word的值 打印局部变量 命令作用info locals打印当前函数局部变量的值backtrace full打印当前栈帧各个函数的局部变量值，命令可缩写为btbt full n从内到外显示n个栈帧及其局部变量bt full -n从外向内显示n个栈帧及其局部变量 打印结构体 命令作用set print pretty on每行只显示结构体的一名成员set print null-stop不显示'\\000'这种 函数跳转 命令作用set step-mode on不跳过不含调试信息的函数，可以显示和调试汇编代码finish执行完当前函数并打印返回值，然后触发中断return 0不再执行后面的指令，直接返回，可以指定返回值call printf(\"%s\\n\", str)调用printf函数，打印字符串(可以使用call或者print调用函数)print func()调用func函数(可以使用call或者print调用函数)set var variable=xxx设置变量variable的值为xxxset {type}address = xxx给存储地址为address，类型为type的变量赋值info frame显示函数堆栈的信息（堆栈帧地址、指令寄存器的值等） 其它 图形化 tui为terminal user interface的缩写，在启动时候指定-tui参数，或者调试时使用ctrl+x+a组合键，可进入或退出图形化界面。\n命令含义layout src显示源码窗口layout asm显示汇编窗口layout split显示源码 + 汇编窗口layout regs显示寄存器 + 源码或汇编窗口winheight src +5源码窗口高度增加5行winheight asm -5汇编窗口高度减小5行winheight cmd +5控制台窗口高度增加5行winheight regs -5寄存器窗口高度减小5行 汇编 命令含义disassemble function查看函数的汇编代码disassemble /mr function同时比较函数源代码和汇编代码 调试和保存core文件 命令含义file exec_file *# *加载可执行文件的符号表信息core core_file加载core-dump文件gcore core_file生成core-dump文件，记录当前进程的状态 启动方式 使用gdb调试，一般有以下几种启动方式：\ngdb filename: 调试可执行程序\ngdb attach pid: 通过”绑定“进程ID来调试正在运行的进程\ngdb filename -c coredump_file: 调试可执行文件\n在下面的几节中，将分别对上述几种调试方式进行讲解，从例子的角度出发，使得大家能够更好的掌握调试技巧。\n调试 可执行文件 单线程 首先，我们先看一段代码：\n#include void print(int xx, int *xxptr) { printf(\"In print():\\n\"); printf(\" xx is %d and is stored at %p.\\n\", xx, \u0026xx); printf(\" ptr points to %p which holds %d.\\n\", xxptr, *xxptr); } int main(void) { int x = 10; int *ptr = \u0026x; printf(\"In main():\\n\"); printf(\" x is %d and is stored at %p.\\n\", x, \u0026x); printf(\" ptr points to %p which holds %d.\\n\", ptr, *ptr); print(x, ptr); return 0; } 这个代码比较简单，下面我们开始进入调试：\ngdb ./test_main GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-114.el7 Copyright (C) 2013 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type \"show copying\" and \"show warranty\" for details. This GDB was configured as \"x86_64-redhat-linux-gnu\". For bug reporting instructions, please see: ... Reading symbols from /root/test_main...done. (gdb) r Starting program: /root/./test_main In main(): x is 10 and is stored at 0x7fffffffe424. ptr points to 0x7fffffffe424 which holds 10. In print(): xx is 10 and is stored at 0x7fffffffe40c. xxptr points to 0x7fffffffe424 which holds 10. [Inferior 1 (process 31518) exited normally] Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 在上述命令中，我们通过gdb test命令启动调试，然后通过执行r(run命令的缩写)执行程序，直至退出，换句话说，上述命令是一个完整的使用gdb运行可执行程序的完整过程(只使用了r命令)，接下来，我们将以此为例子，介绍几种比较常见的命令。\n断点 (gdb) b 15 Breakpoint 1 at 0x400601: file test_main.cc, line 15. (gdb) info b Num Type Disp Enb Address What 1 breakpoint keep y 0x0000000000400601 in main() at test_main.cc:15(gdb) rStarting program: /root/./test_mainIn main(): x is 10 and is stored at 0x7fffffffe424. ptr points to 0x7fffffffe424 which holds 10.Breakpoint 1, main () at test_main.cc:1515 print(xx, xxptr); Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 (gdb) backtrace (gdb) backtrace #0 main () at test_main.cc:15 (gdb) backtrace命令是列出当前堆栈中的所有帧。在上面的例子中，栈上只有一帧，编号为0，属于main函数。\n(gdb) step print (xx=10, xxptr=0x7fffffffe424) at test_main.cc:4 4 printf(\"In print():\\n\"); (gdb) 接着，我们执行了step命令，即进入函数内。下面我们继续通过backtrace命令来查看栈帧信息。\n(gdb) backtrace #0 print (xx=10, xxptr=0x7fffffffe424) at test_main.cc:4 #1 0x0000000000400612 in main () at test_main.cc:15 (gdb) 从上面输出结果，我们能够看出，有两个栈帧，第1帧属于main函数，第0帧属于print函数。\n每个栈帧都列出了该函数的参数列表。从上面我们可以看出，main函数没有参数，而print函数有参数，并且显示了其参数的值。\n有一点我们可能比较迷惑，在第一次执行backtrace的时候，main函数所在的栈帧编号为0，而第二次执行的时候，main函数的栈帧为1，而print函数的栈帧为0，这是因为_与栈的向下增长_规律一致，我们只需要记住_编号最小帧号就是最近一次调用的函数_。\nframe 栈帧用来存储函数的变量值等信息，默认情况下，GDB总是位于当前正在执行函数对应栈帧的上下文中。\n在前面的例子中，由于当前正在print()函数中执行，GDB位于第0帧的上下文中。·可以通过frame命令来获取当前正在执行的上下文所在的帧`。\n#0 print (xx=10, xxptr=0x7fffffffe424) at test_main.cc:4 4 printf(\"In print():\\n\"); (gdb) 下面，我们尝试使用print命令打印下当前栈帧的值，如下：\n(gdb) print xx $1 = 10 (gdb) print xxptr $2 = (int *) 0x7fffffffe424 (gdb) 如果我们想看其他栈帧的内容呢？比如main函数中x和ptr的信息呢？假如直接打印这俩值的话，那么就会得到如下：\n(gdb) print x No symbol \"x\" in current context. (gdb) print xxptr No symbol \"ptr\" in current context. (gdb) 在此，我们可以通过frame num来切换栈帧，如下：\n(gdb) frame 1 #1 0x0000000000400612 in main () at test_main.cc:15 15 print(x, ptr); (gdb) print x $3 = 10 (gdb) print ptr $4 = (int *) 0x7fffffffe424 (gdb) 多线程 为了方便进行演示，我们创建一个简单的例子，代码如下：\n#include #include #include #include #include int fun_int(int n) { std::this_thread::sleep_for(std::chrono::seconds(10)); std::cout \u003c\u003c \"in fun_int n = \" \u003c\u003c n \u003c\u003c std::endl; return 0; } int fun_string(const std::string \u0026s) { std::this_thread::sleep_for(std::chrono::seconds(10)); std::cout \u003c\u003c \"in fun_string s = \" \u003c\u003c s \u003c\u003c std::endl; return 0; } int main() { std::vector\u003cint\u003e v; v.emplace_back(1); v.emplace_back(2); v.emplace_back(3); std::cout \u003c\u003c v.size() \u003c\u003c std::endl; std::thread t1(fun_int, 1); std::thread t2(fun_string, \"test\"); std::cout \u003c\u003c \"after thread create\" \u003c\u003c std::endl; t1.join(); t2.join(); return 0; } 上述代码比较简单：\n函数fun_int的功能是休眠10s，然后打印其参数\n函数fun_string功能是休眠10s，然后打印其参数\nmain函数中，创建两个线程，分别执行上述两个函数\n下面是一个完整的调试过程：\n(gdb) b 27 Breakpoint 1 at 0x4013d5: file test.cc, line 27. (gdb) b test.cc:32 Breakpoint 2 at 0x40142d: file test.cc, line 32. (gdb) info b Num Type Disp Enb Address What 1 breakpoint keep y 0x00000000004013d5 in main() at test.cc:272 breakpoint keep y 0x000000000040142d in main() at test.cc:32(gdb) rStarting program: /root/test[Thread debugging using libthread_db enabled]Using host libthread_db library \"/lib64/libthread_db.so.1\".Breakpoint 1, main () at test.cc:27(gdb) cContinuing.3[New Thread 0x7ffff6fd2700 (LWP 44996)]in fun_int n = 1 [New Thread 0x7ffff67d1700 (LWP 44997)] Breakpoint 2, main () at test.cc:32 32 std::cout \u003c\u003c \"after thread create\" \u003c\u003c std::endl; (gdb) info threads Id Target Id Frame 3 Thread 0x7ffff67d1700 (LWP 44997) \"test\" 0x00007ffff7051fc3 in new_heap () from /lib64/libc.so.6 2 Thread 0x7ffff6fd2700 (LWP 44996) \"test\" 0x00007ffff7097e2d in nanosleep () from /lib64/libc.so.6* 1 Thread 0x7ffff7fe7740 (LWP 44987) \"test\" main () at test.cc:32(gdb) thread 2[Switching to thread 2 (Thread 0x7ffff6fd2700 (LWP 44996))]#0 0x00007ffff7097e2d in nanosleep () from /lib64/libc.so.6(gdb) bt#0 0x00007ffff7097e2d in nanosleep () from /lib64/libc.so.6#1 0x00007ffff7097cc4 in sleep () from /lib64/libc.so.6#2 0x00007ffff796ceb9 in std::this_thread::__sleep_for(std::chrono::duration","wordCount":"2006","inLanguage":"zh","image":"https://codebearjourney.top/images/peace.png","datePublished":"2025-10-25T21:18:14+08:00","dateModified":"2025-10-25T21:18:14+08:00","author":{"@type":"Person","name":"Tianyu Xiong"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://codebearjourney.top/posts/gdb%E8%B0%83%E8%AF%95-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%E5%88%B0%E5%8E%9F%E7%90%86/"},"publisher":{"@type":"Organization","name":"codebear","logo":{"@type":"ImageObject","url":"https://codebearjourney.top/favicon/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://codebearjourney.top/ accesskey=h title="Sachi's Blog (Alt + H)"><img src=https://codebearjourney.top/images/avatar.png alt aria-label=logo height=35>Sachi's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://codebearjourney.top/ title=主页><span>主页</span></a></li><li><a href=https://codebearjourney.top/archives/ title=归档><span>归档</span></a></li><li><a href=https://codebearjourney.top/series/ title=专栏><span>专栏</span></a></li><li><a href=https://codebearjourney.top/categories/ title=分类><span>分类</span></a></li><li><a href=https://codebearjourney.top/tags/ title=标签><span>标签</span></a></li><li><a href=https://codebearjourney.top/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://codebearjourney.top/about/ title=关于><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://codebearjourney.top/>主页</a>&nbsp;»&nbsp;<a href=https://codebearjourney.top/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">GDB调试: 从入门实践到原理</h1><div class=post-description>全面介绍 GDB 调试器的使用方法，从基础命令到高级技巧，再到底层实现原理</div><div class=post-meta><span title='2025-10-25 21:18:14 +0800 +0800'>10月 25, 2025</span>&nbsp;·&nbsp;<span>10 分钟</span>&nbsp;·&nbsp;<span>2006 字</span>&nbsp;·&nbsp;<span>Tianyu Xiong</span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e5%86%99%e5%9c%a8%e5%89%8d%e9%9d%a2 aria-label=写在前面>写在前面</a></li><li><a href=#%e8%83%8c%e6%99%af aria-label=背景>背景</a></li><li><a href=#%e6%a6%82%e5%bf%b5 aria-label=概念>概念</a></li><li><a href=#%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4 aria-label=常用命令>常用命令</a><ul><li><a href=#%e6%96%ad%e7%82%b9 aria-label=断点>断点</a><ul><li><a href=#breakpoint aria-label=breakpoint>breakpoint</a></li><li><a href=#watchpoint aria-label=watchpoint>watchpoint</a></li><li><a href=#catchpoint aria-label=catchpoint>catchpoint</a></li></ul></li><li><a href=#%e5%91%bd%e4%bb%a4%e8%a1%8c aria-label=命令行>命令行</a></li><li><a href=#%e7%a8%8b%e5%ba%8f%e6%a0%88 aria-label=程序栈>程序栈</a></li><li><a href=#%e5%a4%9a%e8%bf%9b%e7%a8%8b%e5%a4%9a%e7%ba%bf%e7%a8%8b aria-label=多进程、多线程>多进程、多线程</a><ul><li><a href=#%e5%a4%9a%e8%bf%9b%e7%a8%8b aria-label=多进程>多进程</a></li><li><a href=#%e5%a4%9a%e7%ba%bf%e7%a8%8b aria-label=多线程>多线程</a></li></ul></li><li><a href=#%e6%89%93%e5%8d%b0%e8%be%93%e5%87%ba aria-label=打印输出>打印输出</a><ul><ul><li><a href=#%e6%89%93%e5%8d%b0%e5%ad%97%e7%ac%a6%e4%b8%b2 aria-label=打印字符串>打印字符串</a></li><li><a href=#%e6%89%93%e5%8d%b0%e6%95%b0%e7%bb%84 aria-label=打印数组>打印数组</a></li><li><a href=#%e6%89%93%e5%8d%b0%e6%8c%87%e9%92%88 aria-label=打印指针>打印指针</a></li><li><a href=#%e6%89%93%e5%8d%b0%e6%8c%87%e5%ae%9a%e5%86%85%e5%ad%98%e5%9c%b0%e5%9d%80%e7%9a%84%e5%80%bc aria-label=打印指定内存地址的值>打印指定内存地址的值</a></li><li><a href=#%e6%89%93%e5%8d%b0%e5%b1%80%e9%83%a8%e5%8f%98%e9%87%8f aria-label=打印局部变量>打印局部变量</a></li><li><a href=#%e6%89%93%e5%8d%b0%e7%bb%93%e6%9e%84%e4%bd%93 aria-label=打印结构体>打印结构体</a></li></ul></ul></li><li><a href=#%e5%87%bd%e6%95%b0%e8%b7%b3%e8%bd%ac aria-label=函数跳转>函数跳转</a></li><li><a href=#%e5%85%b6%e5%ae%83 aria-label=其它>其它</a><ul><li><a href=#%e5%9b%be%e5%bd%a2%e5%8c%96 aria-label=图形化>图形化</a></li><li><a href=#%e6%b1%87%e7%bc%96 aria-label=汇编>汇编</a></li><li><a href=#%e8%b0%83%e8%af%95%e5%92%8c%e4%bf%9d%e5%ad%98core%e6%96%87%e4%bb%b6 aria-label=调试和保存core文件>调试和保存core文件</a></li></ul></li></ul></li><li><a href=#%e5%90%af%e5%8a%a8%e6%96%b9%e5%bc%8f aria-label=启动方式>启动方式</a></li><li><a href=#%e8%b0%83%e8%af%95 aria-label=调试>调试</a><ul><li><a href=#%e5%8f%af%e6%89%a7%e8%a1%8c%e6%96%87%e4%bb%b6 aria-label=可执行文件>可执行文件</a><ul><li><a href=#%e5%8d%95%e7%ba%bf%e7%a8%8b aria-label=单线程>单线程</a><ul><li><a href=#%e6%96%ad%e7%82%b9-1 aria-label=断点>断点</a></li><li><a href=#backtrace aria-label=backtrace>backtrace</a></li><li><a href=#frame aria-label=frame>frame</a></li></ul></li><li><a href=#%e5%a4%9a%e7%ba%bf%e7%a8%8b-1 aria-label=多线程>多线程</a></li><li><a href=#%e5%a4%9a%e8%bf%9b%e7%a8%8b-1 aria-label=多进程>多进程</a><ul><li><a href=#attach aria-label=attach>attach</a></li><li><a href=#%e6%8c%87%e5%ae%9a%e8%bf%9b%e7%a8%8b aria-label=指定进程>指定进程</a><ul><li><a href=#follow-fork-mode aria-label=follow-fork-mode>follow-fork-mode</a></li><li><a href=#detach-on-fork aria-label=detach-on-fork>detach-on-fork</a></li></ul></li></ul></li></ul></li><li><a href=#coredump aria-label=coredump>coredump</a><ul><ul><li><a href=#%e9%85%8d%e7%bd%ae aria-label=配置>配置</a><ul><li><a href=#%e4%b8%b4%e6%97%b6 aria-label=临时>临时</a></li><li><a href=#%e6%b0%b8%e4%b9%85 aria-label=永久>永久</a></li></ul></li><li><a href=#%e8%b0%83%e8%af%95-1 aria-label=调试>调试</a></li></ul></ul></li></ul></li><li><a href=#%e5%8e%9f%e7%90%86 aria-label=原理>原理</a><ul><li><a href=#%e8%b0%83%e8%af%95%e5%8e%9f%e7%90%86 aria-label=调试原理>调试原理</a><ul><li><a href=#%e8%bf%90%e8%a1%8c%e5%b9%b6%e8%b0%83%e8%af%95%e6%96%b0%e8%bf%9b%e7%a8%8b aria-label=运行并调试新进程>运行并调试新进程</a></li><li><a href=#attach%e8%bf%90%e8%a1%8c%e7%9a%84%e8%bf%9b%e7%a8%8b aria-label=attach运行的进程>attach运行的进程</a></li></ul></li><li><a href=#%e6%96%ad%e7%82%b9%e5%8e%9f%e7%90%86 aria-label=断点原理>断点原理</a><ul><li><a href=#%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86 aria-label=实现原理>实现原理</a></li><li><a href=#%e8%ae%be%e7%bd%ae%e5%8e%9f%e7%90%86 aria-label=设置原理>设置原理</a></li><li><a href=#%e5%91%bd%e4%b8%ad%e5%88%a4%e6%96%ad aria-label=命中判断>命中判断</a></li><li><a href=#%e6%9d%a1%e4%bb%b6%e5%88%a4%e6%96%ad aria-label=条件判断>条件判断</a></li></ul></li><li><a href=#%e5%8d%95%e6%ad%a5%e5%8e%9f%e7%90%86 aria-label=单步原理>单步原理</a></li></ul></li><li><a href=#%e5%85%b6%e5%ae%83-1 aria-label=其它>其它</a><ul><li><a href=#pstack aria-label=pstack>pstack</a></li><li><a href=#ldd aria-label=ldd>ldd</a></li><li><a href=#cfilt aria-label=c++filt>c++filt</a></li></ul></li><li><a href=#%e7%bb%93%e8%af%ad aria-label=结语>结语</a></li><li><a href=#%e5%8f%82%e8%80%83 aria-label=参考>参考</a></li></ul></div></details></div></aside><script>let activeElement,elements;document.addEventListener("DOMContentLoaded",function(){if(checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),elements.length>0){activeElement=elements[0];const e=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${e}"]`).classList.add("active")}const t=document.getElementById("top-link");t&&t.addEventListener("click",e=>{e.preventDefault(),window.scrollTo({top:0,behavior:"smooth"})})},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{const e=window.pageYOffset||document.documentElement.scrollTop;if(e===0)return;elements&&elements.length>0&&(activeElement=Array.from(elements).find(t=>{if(getOffsetTop(t)-e>0&&getOffsetTop(t)-e<window.innerHeight/2)return t})||activeElement,elements.forEach(e=>{const n=encodeURI(e.getAttribute("id")).toLowerCase(),t=document.querySelector(`.inner ul li a[href="#${n}"]`);if(e===activeElement){t.classList.add("active");const e=document.querySelector(".toc .inner"),n=t.offsetTop,s=e.clientHeight,o=t.clientHeight,i=n-s/2+o/2;e.scrollTo({top:i,behavior:"smooth"})}else t.classList.remove("active")}))},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>一直有读者在问，能不能写一篇关于gdb调试方面的文章，今天借助此文，分享一些工作中的调试经验，希望能够帮到大家。</p><h2 id=写在前面>写在前面<a hidden class=anchor aria-hidden=true href=#写在前面>#</a></h2><p>在我的工作经历中，前几年在Windows上进行开发，使用Visual Studio进行调试，简直是利器，各种断点等用鼠标点点点就能设置；大概从12年开始转Linux开发了，所以调试都是基于GDB的。本来这篇文章也想写写Windows下调试相关，奈何好多年没用了，再加上工作太忙，所以本文就只写了Linux下GDB调试相关，对于Windows开发人员，实在对不住了😃。</p><p>这篇文章，涉及的比较全面，总结了这些年的gdb调试经验(都是小儿科😁)，经常用到的一些调试技巧，希望能够对从事Linux开发的相关人员有所帮助</p><p><img alt=gdb-mind-map loading=lazy src=https://cdn.jsdelivr.net/gh/tianyuxbear/images/blog/gdb-mind-map.png></p><h2 id=背景>背景<a hidden class=anchor aria-hidden=true href=#背景>#</a></h2><p>作为C/C++开发人员，保证程序正常运行是最基本也是最主要的目的。而为了保证程序正常运行，调试则是最基本的手段，熟悉这些调试方式，可以方便我们更快的定位程序问题所在，提高开发效率。</p><p>在开发过程，如果程序的运行结果不符合预期，第一时间就是打开GDB进行调试，在对应的地方<code>设置断点</code>，然后分析原因；当线上服务出了问题，第一时间查看进程在不在，如果不在的话，是否生成了<code>coredump文件</code>，如果有，则使用gdb调试coredump文件，否则通过<code>dmesg</code>来分析内核日志来查找原因。</p><h2 id=概念>概念<a hidden class=anchor aria-hidden=true href=#概念>#</a></h2><p>GDB是一个由GNU开源组织发布的、UNIX/LINUX操作系统下的、<strong>「基于命令行的、功能强大的程序调试工具」</strong>。</p><p>GDB支持断点、单步执行、打印变量、观察变量、查看寄存器、查看堆栈等调试手段。在Linux环境软件开发中，GDB是主要的调试工具，用来调试C和 C++程序(也支持go等其他语言)。</p><h2 id=常用命令>常用命令<a hidden class=anchor aria-hidden=true href=#常用命令>#</a></h2><h3 id=断点>断点<a hidden class=anchor aria-hidden=true href=#断点>#</a></h3><p>断点是我们在调试中经常用的一个功能，我们在指定位置设置断点之后，程序运行到该位置将会<code>暂停</code>，这个时候我们就可以对程序进行更多的操作，比如查看<code>变量内容，堆栈情况</code>等等，以帮助我们调试程序。</p><p>以设置断点的命令分为以下几类：</p><ul><li><p>breakpoint</p></li><li><p>watchpoint</p></li><li><p>catchpoint</p></li></ul><h4 id=breakpoint>breakpoint<a hidden class=anchor aria-hidden=true href=#breakpoint>#</a></h4><p>可以根据行号、函数、条件生成断点，下面是相关命令以及对应的作用说明：</p><table><thead><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><th style=border-top-width:1px;border-color:#ccc;text-align:left;background-color:#f0f0f0;font-size:14px;color:#595959;min-width:85px>命令</th><th style=border-top-width:1px;border-color:#ccc;text-align:left;background-color:#f0f0f0;font-size:14px;color:#595959;min-width:85px>作用</th></tr></thead><tbody style=border-width:0;border-style:initial;border-color:initial><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>break [file]:function</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>在文件file的function函数入口设置断点</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#f8f8f8"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>break [file]:line</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>在文件file的第line行设置断点</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>info breakpoints</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>查看断点列表</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#f8f8f8"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>break [+-]offset</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>在当前位置偏移量为[+-]offset处设置断点</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>break *addr</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>在地址addr处设置断点</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#f8f8f8"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>break ... if expr</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>设置条件断点，仅仅在条件满足时</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>ignore n count</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>接下来对于编号为n的断点忽略count次</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#f8f8f8"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>clear</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>删除所有断点</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>clear function</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>删除所有位于function内的断点</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#f8f8f8"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>delete n</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>删除指定编号的断点</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>enable n</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>启用指定编号的断点</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#f8f8f8"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>disable n</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>禁用指定编号的断点</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>save breakpoints file</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>保存断点信息到指定文件</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#f8f8f8"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>source file</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>导入文件中保存的断点信息</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>break</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>在下一个指令处设置断点</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#f8f8f8"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>clear [file:]line</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>删除第line行的断点</span></td></tr></tbody></table><h4 id=watchpoint>watchpoint<a hidden class=anchor aria-hidden=true href=#watchpoint>#</a></h4><p>watchpoint是一种特殊类型的断点，类似于正常断点，是要求GDB暂停程序执行的命令。区别在于watchpoint<code>没有驻留</code>某一行源代码中，而是指示GDB每当某个表达式改变了值就<code>暂停执行</code>的命令。</p><p>watchpoint分为<code>硬件实现和软件实现</code>两种。前者需要硬件系统的支持；后者的原理就是每步执行后都检查变量的值是否改变。GDB在新建数据断点时会优先尝试硬件方式，如果失败再尝试软件实现。</p><table><thead><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><th style=border-top-width:1px;border-color:#ccc;text-align:left;background-color:#f0f0f0;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>命令</span></th><th style=border-top-width:1px;border-color:#ccc;text-align:left;background-color:#f0f0f0;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>作用</span></th></tr></thead><tbody style=border-width:0;border-style:initial;border-color:initial><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>watch variable</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>设置变量数据断点</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#f8f8f8"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>watch var1 + var2</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>设置表达式数据断点</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>rwatch variable</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>设置读断点，仅支持硬件实现</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#f8f8f8"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>awatch variable</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>设置读写断点，仅支持硬件实现</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>info watchpoints</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>查看数据断点列表</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#f8f8f8"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>set can-use-hw-watchpoints 0</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>强制基于软件方式实现</span></td></tr></tbody></table><p>使用数据断点时，需要注意：</p><ul><li><p>当监控变量为局部变量时，一旦局部变量失效，数据断点也会失效</p></li><li><p>如果监控的是指针变量<code>p</code>，则<code>watch *p</code>监控的是<code>p</code>所指内存数据的变化情况，而<code>watch p</code>监控的是p指针本身有没有改变指向</p></li></ul><p>最常见的数据断点应用场景：<strong>「定位堆上的结构体内部成员何时被修改」</strong>。由于指针一般为局部变量，为了解决断点失效，一般有两种方法。</p><table><thead><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><th style=border-top-width:1px;border-color:#ccc;text-align:left;background-color:#f0f0f0;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>命令</span></th><th style=border-top-width:1px;border-color:#ccc;text-align:left;background-color:#f0f0f0;font-size:14px;color:#595959;min-width:85px>作用</th></tr></thead><tbody style=border-width:0;border-style:initial;border-color:initial><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>print &amp;variable</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>查看变量的内存地址</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#f8f8f8"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>watch *(type *)address</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>通过内存地址间接设置断点</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>watch -l variable</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>指定location参数</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#f8f8f8"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>watch variable thread 1</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>仅编号为1的线程修改变量var值时会中断</span></td></tr></tbody></table><h4 id=catchpoint>catchpoint<a hidden class=anchor aria-hidden=true href=#catchpoint>#</a></h4><p>从字面意思理解，是捕获断点，其主要监测信号的产生。例如c++的throw，或者加载库的时候，产生断点行为。</p><table><thead><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><th style=border-top-width:1px;border-color:#ccc;text-align:justify;background-color:#f0f0f0;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>命令</span></th><th style=border-top-width:1px;border-color:#ccc;text-align:justify;background-color:#f0f0f0;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>含义</span></th></tr></thead><tbody style=border-width:0;border-style:initial;border-color:initial><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>catch fork</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>程序调用fork时中断</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#f8f8f8"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>tcatch fork</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>设置的断点只触发一次，之后被自动删除</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>catch syscall ptrace</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>为ptrace系统调用设置断点</span></td></tr></tbody></table><blockquote><p>[!tip] Tips
在<code>command</code>命令后加断点编号，可以定义断点触发后想要执行的操作。在一些高级的自动化调试场景中可能会用到。</p></blockquote><h3 id=命令行>命令行<a hidden class=anchor aria-hidden=true href=#命令行>#</a></h3><table><thead><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><th style=border-top-width:1px;border-color:#ccc;text-align:left;background-color:#f0f0f0;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>命令</span></th><th style=border-top-width:1px;border-color:#ccc;text-align:left;background-color:#f0f0f0;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>作用</span></th></tr></thead><tbody style=border-width:0;border-style:initial;border-color:initial><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>run arglist</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>以arglist为参数列表运行程序</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#f8f8f8"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>set args arglist</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>指定启动命令行参数</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>set args</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>指定空的参数列表</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#f8f8f8"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>show args</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>打印命令行列表</span></td></tr></tbody></table><h3 id=程序栈>程序栈<a hidden class=anchor aria-hidden=true href=#程序栈>#</a></h3><table><thead><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><th style=border-top-width:1px;border-color:#ccc;text-align:left;background-color:#f0f0f0;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>命令</span></th><th style=border-top-width:1px;border-color:#ccc;text-align:left;background-color:#f0f0f0;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>作用</span></th></tr></thead><tbody style=border-width:0;border-style:initial;border-color:initial><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>backtrace [n]</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>打印栈帧</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#f8f8f8"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>frame [n]</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>选择第n个栈帧，如果不存在，则打印当前栈帧</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>up n</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>选择当前栈帧编号+n的栈帧</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#f8f8f8"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>down n</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>选择当前栈帧编号-n的栈帧</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>info frame [addr]</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>描述当前选择的栈帧</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#f8f8f8"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>info args</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>当前栈帧的参数列表</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>info locals</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>当前栈帧的局部变量</span></td></tr></tbody></table><h3 id=多进程多线程>多进程、多线程<a hidden class=anchor aria-hidden=true href=#多进程多线程>#</a></h3><h4 id=多进程>多进程<a hidden class=anchor aria-hidden=true href=#多进程>#</a></h4><p>GDB在调试多进程程序（程序含<code>fork</code>调用）时，默认只追踪父进程。可以通过命令设置，实现只追踪父进程或子进程，或者同时调试父进程和子进程。</p><table><thead><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><th style=border-top-width:1px;border-color:#ccc;text-align:justify;background-color:#f0f0f0;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>命令</span></th><th style=border-top-width:1px;border-color:#ccc;text-align:justify;background-color:#f0f0f0;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>作用</span></th></tr></thead><tbody style=border-width:0;border-style:initial;border-color:initial><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>info inferiors</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>查看进程列表</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#f8f8f8"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>attach pid</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>绑定进程id</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>inferior num</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>切换到指定进程上进行调试</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#f8f8f8"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>print $_exitcode</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>显示程序退出时的返回值</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>set follow-fork-mode child</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>追踪子进程</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#f8f8f8"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>set follow-fork-mode parent</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>追踪父进程</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>set detach-on-fork on</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>fork调用时只追踪其中一个进程</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#f8f8f8"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>set detach-on-fork off</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>fork调用时会同时追踪父子进程</span></td></tr></tbody></table><p>在调试多进程程序时候，默认情况下，除了当前调试的进程，其他进程都处于挂起状态，所以，如果需要在调试当前进程的时候，其他进程也能正常执行，那么通过设置<code>set schedule-multiple on</code>即可。</p><h4 id=多线程>多线程<a hidden class=anchor aria-hidden=true href=#多线程>#</a></h4><p>多线程开发在日常开发工作中很常见，所以多线程的调试技巧非常有必要掌握。</p><p>默认调试多线程时，一旦程序中断，所有线程都将暂停。如果此时再继续执行当前线程，其他线程也会同时执行。</p><table><thead><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><th style=border-top-width:1px;border-color:#ccc;text-align:justify;background-color:#f0f0f0;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>命令</span></th><th style=border-top-width:1px;border-color:#ccc;text-align:justify;background-color:#f0f0f0;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>作用</span></th></tr></thead><tbody style=border-width:0;border-style:initial;border-color:initial><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>info threads</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>查看线程列表</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#f8f8f8"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>print $_thread</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>显示当前正在调试的线程编号</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>set scheduler-locking on</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>调试一个线程时，其他线程暂停执行</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#f8f8f8"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>set scheduler-locking off</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>调试一个线程时，其他线程同步执行</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>set scheduler-locking step</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>仅用step调试线程时其他线程不执行，用其他命令如next调试时仍执行</span></td></tr></tbody></table><p>如果只关心当前线程，建议临时设置<code>scheduler-locking</code>为<code>on</code>，避免其他线程同时运行，导致命中其他断点分散注意力。</p><h3 id=打印输出>打印输出<a hidden class=anchor aria-hidden=true href=#打印输出>#</a></h3><p>通常情况下，在调试的过程中，我们需要查看某个变量的值，以分析其是否符合预期，这个时候就需要打印输出变量值。</p><table><thead><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><th style=border-top-width:1px;border-color:#ccc;text-align:justify;background-color:#f0f0f0;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>命令</span></th><th style=border-top-width:1px;border-color:#ccc;text-align:justify;background-color:#f0f0f0;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>作用</span></th></tr></thead><tbody style=border-width:0;border-style:initial;border-color:initial><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>whatis variable</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>查看变量的类型</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#f8f8f8"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>ptype variable</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>查看变量详细的类型信息</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>info variables var</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>查看定义该变量的文件，不支持局部变量</span></td></tr></tbody></table><h5 id=打印字符串>打印字符串<a hidden class=anchor aria-hidden=true href=#打印字符串>#</a></h5><p>使用<code>x/s</code>命令打印<code>ASCII</code>字符串，如果是宽字符字符串，需要先看宽字符的长度<code>print sizeof(str)</code>。</p><p>如果长度为<code>2</code>，则使用<code>x/hs</code>打印；如果长度为<code>4</code>，则使用<code>x/ws</code>打印。</p><table><thead><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><th style=border-top-width:1px;border-color:#ccc;text-align:justify;background-color:#f0f0f0;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>命令</span></th><th style=border-top-width:1px;border-color:#ccc;text-align:justify;background-color:#f0f0f0;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>作用</span></th></tr></thead><tbody style=border-width:0;border-style:initial;border-color:initial><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>x/s str</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>打印字符串</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#f8f8f8"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>set print elements 0</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>打印不限制字符串长度/或不限制数组长度</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>call printf("%s\n",xxx)</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>这时打印出的字符串不会含有多余的转义符</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#f8f8f8"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>printf "%s\n",xxx</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>同上</span></td></tr></tbody></table><h5 id=打印数组>打印数组<a hidden class=anchor aria-hidden=true href=#打印数组>#</a></h5><table><thead><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><th style=border-top-width:1px;border-color:#ccc;text-align:left;background-color:#f0f0f0;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>命令</span></th><th style=border-top-width:1px;border-color:#ccc;text-align:left;background-color:#f0f0f0;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>作用</span></th></tr></thead><tbody style=border-width:0;border-style:initial;border-color:initial><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>print *array@10</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>打印从数组开头连续10个元素的值</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#f8f8f8"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>print array[60]@10</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>打印array数组下标从60开始的10个元素，即第60~69个元素</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>set print array-indexes on</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>打印数组元素时，同时打印数组的下标</span></td></tr></tbody></table><h5 id=打印指针>打印指针<a hidden class=anchor aria-hidden=true href=#打印指针>#</a></h5><table><thead><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><th style=border-top-width:1px;border-color:#ccc;text-align:left;background-color:#f0f0f0;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>命令</span></th><th style=border-top-width:1px;border-color:#ccc;text-align:left;background-color:#f0f0f0;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>作用</span></th></tr></thead><tbody style=border-width:0;border-style:initial;border-color:initial><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>print ptr</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px;word-break:break-all><span style=font-size:15px>查看该指针指向的类型及指针地址</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#f8f8f8"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>print *(struct xxx *)ptr</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>查看指向的结构体的内容</span></td></tr></tbody></table><h5 id=打印指定内存地址的值>打印指定内存地址的值<a hidden class=anchor aria-hidden=true href=#打印指定内存地址的值>#</a></h5><p>使用<code>x</code>命令来打印内存的值，格式为<code>x/nfu addr</code>，以<code>f</code>格式打印从<code>addr</code>开始的<code>n</code>个长度单元为u的内存值。</p><ul><li><p><code>n</code>：输出单元的个数</p></li><li><p><code>f</code>：输出格式，如<code>x</code>表示以<code>16</code>进制输出，<code>o</code>表示以<code>8</code>进制输出，默认为<code>x</code></p></li><li><p><code>u</code>：一个单元的长度，<code>b</code>表示<code>1</code>个<code>byte</code>，<code>h</code>表示<code>2</code>个<code>byte</code>（<code>half word</code>），w表示<code>4</code>个<code>byte</code> ，<code>g</code>表示<code>8</code>个<code>byte</code>（<code>giant word</code>）。</p></li></ul><table><thead><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><th style=border-top-width:1px;border-color:#ccc;text-align:justify;background-color:#f0f0f0;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>命令</span></th><th style=border-top-width:1px;border-color:#ccc;text-align:justify;background-color:#f0f0f0;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>作用</span></th></tr></thead><tbody style=border-width:0;border-style:initial;border-color:initial><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>x/8xb array</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>以16进制打印数组array的前8个byte的值</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#f8f8f8"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>x/8xw array</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>以16进制打印数组array的前16个word的值</span></td></tr></tbody></table><h5 id=打印局部变量>打印局部变量<a hidden class=anchor aria-hidden=true href=#打印局部变量>#</a></h5><table><thead><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><th style=border-top-width:1px;border-color:#ccc;text-align:left;background-color:#f0f0f0;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>命令</span></th><th style=border-top-width:1px;border-color:#ccc;text-align:left;background-color:#f0f0f0;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>作用</span></th></tr></thead><tbody style=border-width:0;border-style:initial;border-color:initial><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>info locals</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>打印当前函数局部变量的值</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#f8f8f8"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>backtrace full</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>打印当前栈帧各个函数的局部变量值，命令可缩写为bt</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>bt full n</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>从内到外显示n个栈帧及其局部变量</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#f8f8f8"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>bt full -n</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>从外向内显示n个栈帧及其局部变量</span></td></tr></tbody></table><h5 id=打印结构体>打印结构体<a hidden class=anchor aria-hidden=true href=#打印结构体>#</a></h5><table><thead><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><th style=border-top-width:1px;border-color:#ccc;text-align:left;background-color:#f0f0f0;font-size:14px;color:#595959;min-width:85px>命令</th><th style=border-top-width:1px;border-color:#ccc;text-align:left;background-color:#f0f0f0;font-size:14px;color:#595959;min-width:85px>作用</th></tr></thead><tbody style=border-width:0;border-style:initial;border-color:initial><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>set print pretty on</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>每行只显示结构体的一名成员</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#f8f8f8"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>set print null-stop</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>不显示'\000'</span><repeat xx times><span style=font-size:15px>这种</span></repeat></td></tr></tbody></table><h3 id=函数跳转>函数跳转<a hidden class=anchor aria-hidden=true href=#函数跳转>#</a></h3><table><thead><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><th style=border-top-width:1px;border-color:#ccc;text-align:left;background-color:#f0f0f0;font-size:14px;color:#595959;min-width:85px>命令</th><th style=border-top-width:1px;border-color:#ccc;text-align:left;background-color:#f0f0f0;font-size:14px;color:#595959;min-width:85px>作用</th></tr></thead><tbody style=border-width:0;border-style:initial;border-color:initial><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px>set step-mode on</td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px>不跳过不含调试信息的函数，可以显示和调试汇编代码</td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#f8f8f8"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px>finish</td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px>执行完当前函数并打印返回值，然后触发中断</td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px>return 0</td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px>不再执行后面的指令，直接返回，可以指定返回值</td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#f8f8f8"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px>call printf("%s\n", str)</td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px>调用printf函数，打印字符串(可以使用call或者print调用函数)</td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px>print func()</td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px>调用func函数(可以使用call或者print调用函数)</td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#f8f8f8"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px>set var variable=xxx</td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px>设置变量variable的值为xxx</td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px>set {type}address = xxx</td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px>给存储地址为address，类型为type的变量赋值</td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#f8f8f8"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px>info frame</td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px>显示函数堆栈的信息（堆栈帧地址、指令寄存器的值等）</td></tr></tbody></table><h3 id=其它>其它<a hidden class=anchor aria-hidden=true href=#其它>#</a></h3><h4 id=图形化>图形化<a hidden class=anchor aria-hidden=true href=#图形化>#</a></h4><p>tui为<code>terminal user interface</code>的缩写，在启动时候指定<code>-tui</code>参数，或者调试时使用<code>ctrl+x+a</code>组合键，可进入或退出图形化界面。</p><table><thead><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><th style=border-top-width:1px;border-color:#ccc;text-align:justify;background-color:#f0f0f0;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>命令</span></th><th style=border-top-width:1px;border-color:#ccc;text-align:justify;background-color:#f0f0f0;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>含义</span></th></tr></thead><tbody style=border-width:0;border-style:initial;border-color:initial><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>layout src</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>显示源码窗口</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#f8f8f8"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>layout asm</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>显示汇编窗口</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>layout split</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>显示源码 + 汇编窗口</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#f8f8f8"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>layout regs</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>显示寄存器 + 源码或汇编窗口</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>winheight src +5</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>源码窗口高度增加5行</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#f8f8f8"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>winheight asm -5</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>汇编窗口高度减小5行</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>winheight cmd +5</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>控制台窗口高度增加5行</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#f8f8f8"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>winheight regs -5</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>寄存器窗口高度减小5行</span></td></tr></tbody></table><h4 id=汇编>汇编<a hidden class=anchor aria-hidden=true href=#汇编>#</a></h4><table><thead><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><th style=border-top-width:1px;border-color:#ccc;text-align:left;background-color:#f0f0f0;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>命令</span></th><th style=border-top-width:1px;border-color:#ccc;text-align:left;background-color:#f0f0f0;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>含义</span></th></tr></thead><tbody style=border-width:0;border-style:initial;border-color:initial><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>disassemble function</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>查看函数的汇编代码</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#f8f8f8"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>disassemble /mr function</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>同时比较函数源代码和汇编代码</span></td></tr></tbody></table><h4 id=调试和保存core文件>调试和保存core文件<a hidden class=anchor aria-hidden=true href=#调试和保存core文件>#</a></h4><table><thead><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><th style=border-top-width:1px;border-color:#ccc;text-align:left;background-color:#f0f0f0;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>命令</span></th><th style=border-top-width:1px;border-color:#ccc;text-align:left;background-color:#f0f0f0;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>含义</span></th></tr></thead><tbody style=border-width:0;border-style:initial;border-color:initial><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>file exec_file  *# *</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>加载可执行文件的符号表信息</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#f8f8f8"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>core core_file</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>加载core-dump文件</span></td></tr><tr style="border-width:1px 0 0;border-right-style:initial;border-bottom-style:initial;border-left-style:initial;border-right-color:initial;border-bottom-color:initial;border-left-color:initial;border-top-style:solid;border-top-color:#ccc;background-color:#fff"><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>gcore core_file</span></td><td style=border-color:#ccc;font-size:14px;color:#595959;min-width:85px><span style=font-size:15px>生成core-dump文件，记录当前进程的状态</span></td></tr></tbody></table><h2 id=启动方式>启动方式<a hidden class=anchor aria-hidden=true href=#启动方式>#</a></h2><p>使用gdb调试，一般有以下几种启动方式：</p><ul><li><p>gdb filename: 调试可执行程序</p></li><li><p>gdb attach pid: 通过”绑定“进程ID来调试正在运行的进程</p></li><li><p>gdb filename -c coredump_file: 调试可执行文件</p></li></ul><p>在下面的几节中，将分别对上述几种调试方式进行讲解，从例子的角度出发，使得大家能够更好的掌握调试技巧。</p><h2 id=调试>调试<a hidden class=anchor aria-hidden=true href=#调试>#</a></h2><h3 id=可执行文件>可执行文件<a hidden class=anchor aria-hidden=true href=#可执行文件>#</a></h3><h4 id=单线程>单线程<a hidden class=anchor aria-hidden=true href=#单线程>#</a></h4><p>首先，我们先看一段代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span><span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>print</span><span class=p>(</span><span class=kt>int</span> <span class=n>xx</span><span class=p>,</span> <span class=kt>int</span> <span class=o>*</span><span class=n>xxptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;In print():</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;   xx is %d and is stored at %p.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>xx</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>xx</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;   ptr points to %p which holds %d.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>xxptr</span><span class=p>,</span> <span class=o>*</span><span class=n>xxptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=o>*</span><span class=n>ptr</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;In main():</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;   x is %d and is stored at %p.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>x</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;   ptr points to %p which holds %d.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>ptr</span><span class=p>,</span> <span class=o>*</span><span class=n>ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>print</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这个代码比较简单，下面我们开始进入调试：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>gdb ./test_main
</span></span><span class=line><span class=cl>GNU gdb <span class=o>(</span>GDB<span class=o>)</span> Red Hat Enterprise Linux 7.6.1-114.el7
</span></span><span class=line><span class=cl>Copyright <span class=o>(</span>C<span class=o>)</span> 2013 Free Software Foundation, Inc.
</span></span><span class=line><span class=cl>License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
</span></span><span class=line><span class=cl>This is free software: you are free to change and redistribute it.
</span></span><span class=line><span class=cl>There is NO WARRANTY, to the extent permitted by law.  Type <span class=s2>&#34;show copying&#34;</span>
</span></span><span class=line><span class=cl>and <span class=s2>&#34;show warranty&#34;</span> <span class=k>for</span> details.
</span></span><span class=line><span class=cl>This GDB was configured as <span class=s2>&#34;x86_64-redhat-linux-gnu&#34;</span>.
</span></span><span class=line><span class=cl>For bug reporting instructions, please see:
</span></span><span class=line><span class=cl>&lt;http://www.gnu.org/software/gdb/bugs/&gt;...
</span></span><span class=line><span class=cl>Reading symbols from /root/test_main...done.
</span></span><span class=line><span class=cl><span class=o>(</span>gdb<span class=o>)</span> r
</span></span><span class=line><span class=cl>Starting program: /root/./test_main
</span></span><span class=line><span class=cl>In main<span class=o>()</span>:
</span></span><span class=line><span class=cl>   x is 10 and is stored at 0x7fffffffe424.
</span></span><span class=line><span class=cl>   ptr points to 0x7fffffffe424 which holds 10.
</span></span><span class=line><span class=cl>In print<span class=o>()</span>:
</span></span><span class=line><span class=cl>   xx is 10 and is stored at 0x7fffffffe40c.
</span></span><span class=line><span class=cl>   xxptr points to 0x7fffffffe424 which holds 10.
</span></span><span class=line><span class=cl><span class=o>[</span>Inferior 1 <span class=o>(</span>process 31518<span class=o>)</span> exited normally<span class=o>]</span>
</span></span><span class=line><span class=cl>Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64
</span></span></code></pre></div><p>在上述命令中，我们通过gdb test命令启动调试，然后通过执行r(run命令的缩写)执行程序，直至退出，换句话说，上述命令是一个完整的使用gdb运行可执行程序的完整过程(只使用了r命令)，接下来，我们将以此为例子，介绍几种比较常见的命令。</p><h5 id=断点-1>断点<a hidden class=anchor aria-hidden=true href=#断点-1>#</a></h5><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>(</span>gdb<span class=o>)</span> b <span class=m>15</span>
</span></span><span class=line><span class=cl>Breakpoint 1 at 0x400601: file test_main.cc, line 15.
</span></span><span class=line><span class=cl><span class=o>(</span>gdb<span class=o>)</span> info b
</span></span><span class=line><span class=cl>Num     Type           Disp Enb Address            What
</span></span><span class=line><span class=cl>1       breakpoint     keep y   0x0000000000400601 in main<span class=o>()</span> at test_main.cc:15<span class=o>(</span>gdb<span class=o>)</span> rStarting program: /root/./test_mainIn main<span class=o>()</span>:   x is 10 and is stored at 0x7fffffffe424.   ptr points to 0x7fffffffe424 which holds 10.Breakpoint 1, main <span class=o>()</span> at test_main.cc:1515   print<span class=o>(</span>xx, xxptr<span class=o>)</span><span class=p>;</span>
</span></span><span class=line><span class=cl>Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64
</span></span><span class=line><span class=cl><span class=o>(</span>gdb<span class=o>)</span>
</span></span></code></pre></div><h5 id=backtrace>backtrace<a hidden class=anchor aria-hidden=true href=#backtrace>#</a></h5><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>(</span>gdb<span class=o>)</span> backtrace
</span></span><span class=line><span class=cl><span class=c1>#0  main () at test_main.cc:15</span>
</span></span><span class=line><span class=cl><span class=o>(</span>gdb<span class=o>)</span>
</span></span></code></pre></div><p>backtrace命令是列出当前堆栈中的所有帧。在上面的例子中，栈上只有一帧，编号为0，属于main函数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>(</span>gdb<span class=o>)</span> step
</span></span><span class=line><span class=cl>print <span class=o>(</span><span class=nv>xx</span><span class=o>=</span>10, <span class=nv>xxptr</span><span class=o>=</span>0x7fffffffe424<span class=o>)</span> at test_main.cc:4
</span></span><span class=line><span class=cl>4   printf<span class=o>(</span><span class=s2>&#34;In print():\n&#34;</span><span class=o>)</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=o>(</span>gdb<span class=o>)</span>
</span></span></code></pre></div><p>接着，我们执行了step命令，即进入函数内。下面我们继续通过backtrace命令来查看栈帧信息。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(gdb) backtrace
</span></span><span class=line><span class=cl>#0  print (xx=10, xxptr=0x7fffffffe424) at test_main.cc:4
</span></span><span class=line><span class=cl>#1  0x0000000000400612 in main () at test_main.cc:15
</span></span><span class=line><span class=cl>(gdb)
</span></span></code></pre></div><p>从上面输出结果，我们能够看出，有两个栈帧，第1帧属于main函数，第0帧属于print函数。</p><p>每个栈帧都列出了该函数的参数列表。从上面我们可以看出，main函数没有参数，而print函数有参数，并且显示了其参数的值。</p><p>有一点我们可能比较迷惑，在第一次执行backtrace的时候，main函数所在的栈帧编号为0，而第二次执行的时候，main函数的栈帧为1，而print函数的栈帧为0，这是因为_与栈的向下增长_规律一致，我们只需要记住_编号最小帧号就是最近一次调用的函数_。</p><h5 id=frame>frame<a hidden class=anchor aria-hidden=true href=#frame>#</a></h5><p>栈帧用来存储函数的变量值等信息，默认情况下，GDB总是位于当前正在执行函数对应栈帧的上下文中。</p><p>在前面的例子中，由于当前正在print()函数中执行，GDB位于第0帧的上下文中。·可以通过frame命令来获取当前正在执行的上下文所在的帧`。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1>#0  print (xx=10, xxptr=0x7fffffffe424) at test_main.cc:4</span>
</span></span><span class=line><span class=cl>4   printf<span class=o>(</span><span class=s2>&#34;In print():\n&#34;</span><span class=o>)</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=o>(</span>gdb<span class=o>)</span>
</span></span></code></pre></div><p>下面，我们尝试使用print命令打印下当前栈帧的值，如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>(</span>gdb<span class=o>)</span> print xx
</span></span><span class=line><span class=cl><span class=nv>$1</span> <span class=o>=</span> <span class=m>10</span>
</span></span><span class=line><span class=cl><span class=o>(</span>gdb<span class=o>)</span> print xxptr
</span></span><span class=line><span class=cl><span class=nv>$2</span> <span class=o>=</span> <span class=o>(</span>int *<span class=o>)</span> 0x7fffffffe424
</span></span><span class=line><span class=cl><span class=o>(</span>gdb<span class=o>)</span>
</span></span></code></pre></div><p>如果我们想看其他栈帧的内容呢？比如main函数中x和ptr的信息呢？假如直接打印这俩值的话，那么就会得到如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>(</span>gdb<span class=o>)</span> print x
</span></span><span class=line><span class=cl>No symbol <span class=s2>&#34;x&#34;</span> in current context.
</span></span><span class=line><span class=cl><span class=o>(</span>gdb<span class=o>)</span> print xxptr
</span></span><span class=line><span class=cl>No symbol <span class=s2>&#34;ptr&#34;</span> in current context.
</span></span><span class=line><span class=cl><span class=o>(</span>gdb<span class=o>)</span>
</span></span></code></pre></div><p>在此，我们可以通过<strong>frame num</strong>来切换栈帧，如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>(</span>gdb<span class=o>)</span> frame <span class=m>1</span>
</span></span><span class=line><span class=cl><span class=c1>#1  0x0000000000400612 in main () at test_main.cc:15</span>
</span></span><span class=line><span class=cl>15   print<span class=o>(</span>x, ptr<span class=o>)</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=o>(</span>gdb<span class=o>)</span> print x
</span></span><span class=line><span class=cl><span class=nv>$3</span> <span class=o>=</span> <span class=m>10</span>
</span></span><span class=line><span class=cl><span class=o>(</span>gdb<span class=o>)</span> print ptr
</span></span><span class=line><span class=cl><span class=nv>$4</span> <span class=o>=</span> <span class=o>(</span>int *<span class=o>)</span> 0x7fffffffe424
</span></span><span class=line><span class=cl><span class=o>(</span>gdb<span class=o>)</span>
</span></span></code></pre></div><h4 id=多线程-1>多线程<a hidden class=anchor aria-hidden=true href=#多线程-1>#</a></h4><p>为了方便进行演示，我们创建一个简单的例子，代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;chrono&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;thread&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;vector&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>fun_int</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>this_thread</span><span class=o>::</span><span class=nf>sleep_for</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>chrono</span><span class=o>::</span><span class=nf>seconds</span><span class=p>(</span><span class=mi>10</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;in fun_int n = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>n</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>fun_string</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>s</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>this_thread</span><span class=o>::</span><span class=nf>sleep_for</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>chrono</span><span class=o>::</span><span class=nf>seconds</span><span class=p>(</span><span class=mi>10</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;in fun_string s = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>s</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>v</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>v</span><span class=p>.</span><span class=nf>emplace_back</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>v</span><span class=p>.</span><span class=nf>emplace_back</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>v</span><span class=p>.</span><span class=nf>emplace_back</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>v</span><span class=p>.</span><span class=nf>size</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=kr>thread</span> <span class=nf>t1</span><span class=p>(</span><span class=n>fun_int</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=kr>thread</span> <span class=nf>t2</span><span class=p>(</span><span class=n>fun_string</span><span class=p>,</span> <span class=s>&#34;test&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;after thread create&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>t1</span><span class=p>.</span><span class=nf>join</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>t2</span><span class=p>.</span><span class=nf>join</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>上述代码比较简单：</p><ul><li><p>函数fun_int的功能是休眠10s，然后打印其参数</p></li><li><p>函数fun_string功能是休眠10s，然后打印其参数</p></li><li><p>main函数中，创建两个线程，分别执行上述两个函数</p></li></ul><p>下面是一个完整的调试过程：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>(</span>gdb<span class=o>)</span> b <span class=m>27</span>
</span></span><span class=line><span class=cl>Breakpoint 1 at 0x4013d5: file test.cc, line 27.
</span></span><span class=line><span class=cl><span class=o>(</span>gdb<span class=o>)</span> b test.cc:32
</span></span><span class=line><span class=cl>Breakpoint 2 at 0x40142d: file test.cc, line 32.
</span></span><span class=line><span class=cl><span class=o>(</span>gdb<span class=o>)</span> info b
</span></span><span class=line><span class=cl>Num     Type           Disp Enb Address            What
</span></span><span class=line><span class=cl>1       breakpoint     keep y   0x00000000004013d5 in main<span class=o>()</span> at test.cc:272       breakpoint     keep y   0x000000000040142d in main<span class=o>()</span> at test.cc:32<span class=o>(</span>gdb<span class=o>)</span> rStarting program: /root/test<span class=o>[</span>Thread debugging using libthread_db enabled<span class=o>]</span>Using host libthread_db library <span class=s2>&#34;/lib64/libthread_db.so.1&#34;</span>.Breakpoint 1, main <span class=o>()</span> at test.cc:27<span class=o>(</span>gdb<span class=o>)</span> cContinuing.3<span class=o>[</span>New Thread 0x7ffff6fd2700 <span class=o>(</span>LWP 44996<span class=o>)]</span>in fun_int <span class=nv>n</span> <span class=o>=</span> <span class=m>1</span>
</span></span><span class=line><span class=cl><span class=o>[</span>New Thread 0x7ffff67d1700 <span class=o>(</span>LWP 44997<span class=o>)]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Breakpoint 2, main <span class=o>()</span> at test.cc:32
</span></span><span class=line><span class=cl>32   std::cout &lt;&lt; <span class=s2>&#34;after thread create&#34;</span> <span class=s>&lt;&lt; std::endl;
</span></span></span><span class=line><span class=cl><span class=s>(gdb) info threads
</span></span></span><span class=line><span class=cl><span class=s>  Id   Target Id         Frame
</span></span></span><span class=line><span class=cl><span class=s>  3    Thread 0x7ffff67d1700 (LWP 44997) &#34;test&#34; 0x00007ffff7051fc3 in new_heap () from /lib64/libc.so.6  2    Thread 0x7ffff6fd2700 (LWP 44996) &#34;test&#34; 0x00007ffff7097e2d in nanosleep () from /lib64/libc.so.6* 1    Thread 0x7ffff7fe7740 (LWP 44987) &#34;test&#34; main () at test.cc:32(gdb) thread 2[Switching to thread 2 (Thread 0x7ffff6fd2700 (LWP 44996))]#0  0x00007ffff7097e2d in nanosleep () from /lib64/libc.so.6(gdb) bt#0  0x00007ffff7097e2d in nanosleep () from /lib64/libc.so.6#1  0x00007ffff7097cc4 in sleep () from /lib64/libc.so.6#2  0x00007ffff796ceb9 in std</span>::this_thread::__sleep_for<span class=o>(</span>std::chrono::duration&lt;long, std::ratio&lt;1l, 1l&gt; &gt;, std::chrono::duration&lt;long, std::ratio&lt;1l, 1000000000l&gt; &gt;<span class=o>)</span> <span class=o>()</span> from /lib64/libstdc++.so.6#3  0x00000000004018cc in std::this_thread::sleep_for&lt;long, std::ratio&lt;1l, 1l&gt; &gt; <span class=o>(</span><span class=nv>__rtime</span><span class=o>=</span>...<span class=o>)</span> at /usr/include/c++/4.8.2/thread:281#4  0x0000000000401307 in fun_int <span class=o>(</span><span class=nv>n</span><span class=o>=</span>1<span class=o>)</span> at test.cc:9#5  0x0000000000404696 in std::_Bind_simple&lt;int <span class=o>(</span>*<span class=o>(</span>int<span class=o>))(</span>int<span class=o>)</span>&gt;::_M_invoke&lt;0ul&gt;<span class=o>(</span>std::_Index_tuple&lt;0ul&gt;<span class=o>)</span> <span class=o>(</span><span class=nv>this</span><span class=o>=</span>0x609080<span class=o>)</span>    at /usr/include/c++/4.8.2/functional:1732#6  0x000000000040443d in std::_Bind_simple&lt;int <span class=o>(</span>*<span class=o>(</span>int<span class=o>))(</span>int<span class=o>)</span>&gt;::operator<span class=o>()()</span> <span class=o>(</span><span class=nv>this</span><span class=o>=</span>0x609080<span class=o>)</span> at /usr/include/c++/4.8.2/functional:1720#7  0x000000000040436e in std::thread::_Impl&lt;std::_Bind_simple&lt;int <span class=o>(</span>*<span class=o>(</span>int<span class=o>))(</span>int<span class=o>)</span>&gt; &gt;::_M_run<span class=o>()</span> <span class=o>(</span><span class=nv>this</span><span class=o>=</span>0x609068<span class=o>)</span> at /usr/include/c++/4.8.2/thread:115#8  0x00007ffff796d070 in ?? <span class=o>()</span> from /lib64/libstdc++.so.6#9  0x00007ffff7bc6dd5 in start_thread <span class=o>()</span> from /lib64/libpthread.so.0#10 0x00007ffff70d0ead in clone <span class=o>()</span> from /lib64/libc.so.6<span class=o>(</span>gdb<span class=o>)</span> cContinuing.after thread createin fun_int <span class=nv>n</span> <span class=o>=</span> <span class=m>1</span>
</span></span><span class=line><span class=cl><span class=o>[</span>Thread 0x7ffff6fd2700 <span class=o>(</span>LWP 45234<span class=o>)</span> exited<span class=o>]</span>
</span></span><span class=line><span class=cl>in fun_string <span class=nv>s</span> <span class=o>=</span> <span class=nb>test</span>
</span></span><span class=line><span class=cl><span class=o>[</span>Thread 0x7ffff67d1700 <span class=o>(</span>LWP 45235<span class=o>)</span> exited<span class=o>]</span>
</span></span><span class=line><span class=cl><span class=o>[</span>Inferior 1 <span class=o>(</span>process 45230<span class=o>)</span> exited normally<span class=o>]</span>
</span></span><span class=line><span class=cl><span class=o>(</span>gdb<span class=o>)</span> q
</span></span></code></pre></div><p>在上述调试过程中：</p><ol><li><p>b 27 在第27行加上断点</p></li><li><p>b test.cc:32 在第32行加上断点(效果与b 32一致)</p></li><li><p>info b 输出所有的断点信息</p></li><li><p>r 程序开始运行，并在第一个断点处暂停</p></li><li><p>c 执行c命令，在第二个断点处暂停，在第一个断点和第二个断点之间，创建了两个线程t1和t2</p></li><li><p>info threads 输出所有的线程信息，从输出上可以看出，总共有3个线程，分别为main线程、t1和t2</p></li><li><p>thread 2 切换至线程2</p></li><li><p>bt 输出线程2的堆栈信息</p></li><li><p>c 直至程序结束</p></li><li><p>q 退出gdb</p></li></ol><h4 id=多进程-1>多进程<a hidden class=anchor aria-hidden=true href=#多进程-1>#</a></h4><p>同上面一样，我们仍然以一个例子进行模拟多进程调试，代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=kt>pid_t</span> <span class=n>pid</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>       <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;fork error</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>       <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>pid</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// 子进程
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>int</span> <span class=n>num</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span><span class=p>(</span><span class=n>num</span> <span class=o>==</span> <span class=mi>1</span><span class=p>){</span>
</span></span><span class=line><span class=cl>          <span class=nf>sleep</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span>
</span></span><span class=line><span class=cl>         <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;this is child,pid = %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>getpid</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span> <span class=c1>// 父进程
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;this is parent,pid = %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>getpid</span><span class=p>());</span>
</span></span><span class=line><span class=cl>      <span class=nf>wait</span><span class=p>(</span><span class=nb>NULL</span><span class=p>);</span> <span class=c1>// 等待子进程退出
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在上面代码中，包含两个进程，一个是父进程(也就是main进程)，另外一个是由fork()函数创建的子进程。</p><p>在默认情况下，在多进程程序中，GDB只调试main进程，也就是说无论程序调用了多少次fork()函数创建了多少个子进程，GDB在默认情况下，只调试父进程。为了支持多进程调试，从GDB版本7.0开始支持单独调试(调试父进程或者子进程)和同时调试多个进程。</p><p>那么，我们该如何调试子进程呢？我们可以使用如下几种方式进行子进程调试。</p><h5 id=attach>attach<a hidden class=anchor aria-hidden=true href=#attach>#</a></h5><p>首先，无论是父进程还是子进程，都可以通过attach命令启动gdb进行调试。我们都知道，对于每个正在运行的程序，操作系统都会为其分配一个唯一ID号，也就是进程ID。如果我们知道了进程ID，就可以使用attach命令对其进行调试了。</p><p>在上面代码中，fork()函数创建的子进程内部，首先会进入while循环sleep，然后在while循环之后调用printf函数。这样做的目的有如下：</p><ul><li><p>帮助attach捕获要调试的进程id</p></li><li><p>在使用gdb进行调试的时候，真正的代码(即print函数)没有被执行，这样就可以从头开始对子进程进行调试</p></li></ul><blockquote><p>[!tip]<br>可能会有疑惑，上面代码以及进入while循环，无论如何是不会执行到下面printf函数。其实，这就是gdb的厉害之处，可以通过gdb命令修改num的值，以便其跳出while循环<br>❞</p></blockquote><p>使用如下命令编译生成可执行文件test_process</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>g++ -g test_process.cc -o test_process
</span></span></code></pre></div><p>现在，我们开始尝试启动调试。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>gdb -q ./test_process
</span></span><span class=line><span class=cl>Reading symbols from /root/test_process...done.
</span></span><span class=line><span class=cl><span class=o>(</span>gdb<span class=o>)</span>
</span></span></code></pre></div><p>这里需要说明下，之所以加-q选项，是想去掉其他不必要的输出，q为quite的缩写。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>(</span>gdb<span class=o>)</span> r
</span></span><span class=line><span class=cl>Starting program: /root/./test_process
</span></span><span class=line><span class=cl>Detaching after fork from child process 37482.
</span></span><span class=line><span class=cl>this is parent,pid <span class=o>=</span> <span class=m>37478</span>
</span></span><span class=line><span class=cl><span class=o>[</span>Inferior 1 <span class=o>(</span>process 37478<span class=o>)</span> exited normally<span class=o>]</span>
</span></span><span class=line><span class=cl>Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 libgcc-4.8.5-36.el7.x86_64 libstdc++-4.8.5-36.el7.x86_64
</span></span><span class=line><span class=cl><span class=o>(</span>gdb<span class=o>)</span> attach <span class=m>37482</span>
</span></span><span class=line><span class=cl>//符号类输出，此处略去
</span></span><span class=line><span class=cl><span class=o>(</span>gdb<span class=o>)</span> n
</span></span><span class=line><span class=cl>Single stepping <span class=k>until</span> <span class=nb>exit</span> from <span class=k>function</span> __nanosleep_nocancel,
</span></span><span class=line><span class=cl>which has no line number information.
</span></span><span class=line><span class=cl>0x00007ffff72b3cc4 in sleep <span class=o>()</span> from /lib64/libc.so.6
</span></span><span class=line><span class=cl><span class=o>(</span>gdb<span class=o>)</span>
</span></span><span class=line><span class=cl>Single stepping <span class=k>until</span> <span class=nb>exit</span> from <span class=k>function</span> sleep,
</span></span><span class=line><span class=cl>which has no line number information.
</span></span><span class=line><span class=cl>main <span class=o>()</span> at test_process.cc:8
</span></span><span class=line><span class=cl>8       <span class=k>while</span><span class=o>(</span><span class=nv>num</span><span class=o>==</span>10<span class=o>){</span>
</span></span><span class=line><span class=cl><span class=o>(</span>gdb<span class=o>)</span>
</span></span></code></pre></div><p>在上述命令中，我们执行了n(next的缩写)，使其重新对while循环的判断体进行判断。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>(</span>gdb<span class=o>)</span> <span class=nb>set</span> <span class=nv>num</span> <span class=o>=</span> <span class=m>1</span>
</span></span><span class=line><span class=cl><span class=o>(</span>gdb<span class=o>)</span> n
</span></span><span class=line><span class=cl>12       printf<span class=o>(</span><span class=s2>&#34;this is child,pid = %d\n&#34;</span>,getpid<span class=o>())</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=o>(</span>gdb<span class=o>)</span> c
</span></span><span class=line><span class=cl>Continuing.
</span></span><span class=line><span class=cl>this is child,pid <span class=o>=</span> <span class=m>37482</span>
</span></span><span class=line><span class=cl><span class=o>[</span>Inferior 1 <span class=o>(</span>process 37482<span class=o>)</span> exited normally<span class=o>]</span>
</span></span><span class=line><span class=cl><span class=o>(</span>gdb<span class=o>)</span>
</span></span></code></pre></div><p>为了退出while循环，我们使用set命令设置了num的值为1，这样条件就会失效退出while循环，进而执行下面的printf()函数；在最后我们执行了c(continue的缩写)命令，支持程序退出。</p><blockquote><p>[!tip]<br>如果程序正在正常运行，出现了死锁等现象，则可以通过ps获取进程ID，然后根据gdb attach pid进行绑定，进而查看堆栈信息</p></blockquote><h5 id=指定进程>指定进程<a hidden class=anchor aria-hidden=true href=#指定进程>#</a></h5><p>默认情况下，GDB调试多进程程序时候，只调试父进程。GDB提供了两个命令，可以通过follow-fork-mode和detach-on-fork来指定调试父进程还是子进程。</p><h6 id=follow-fork-mode>follow-fork-mode<a hidden class=anchor aria-hidden=true href=#follow-fork-mode>#</a></h6><p>该命令的使用方式为：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>(</span>gdb<span class=o>)</span> <span class=nb>set</span> follow-fork-mode mode
</span></span></code></pre></div><p>其中，mode有以下两个选项：</p><ul><li><p>parent:父进程，mode的默认选项</p></li><li><p>child:子进程，其目的是告诉 gdb 在目标应用调用fork之后接着调试子进程而不是父进程，因为在Linux系统中fork()系统调用成功会返回两次，一次在父进程，一次在子进程</p></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>(</span>gdb<span class=o>)</span> show follow-fork-mode
</span></span><span class=line><span class=cl>Debugger response to a program call of fork or vfork is <span class=s2>&#34;parent&#34;</span>.
</span></span><span class=line><span class=cl><span class=o>(</span>gdb<span class=o>)</span> <span class=nb>set</span> follow-fork-mode child
</span></span><span class=line><span class=cl><span class=o>(</span>gdb<span class=o>)</span> r
</span></span><span class=line><span class=cl>Starting program: /root/./test_process
</span></span><span class=line><span class=cl><span class=o>[</span>New process 37830<span class=o>]</span>
</span></span><span class=line><span class=cl>this is parent,pid <span class=o>=</span> <span class=m>37826</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>^C
</span></span><span class=line><span class=cl>Program received signal SIGINT, Interrupt.
</span></span><span class=line><span class=cl><span class=o>[</span>Switching to process 37830<span class=o>]</span>
</span></span><span class=line><span class=cl>0x00007ffff72b3e10 in __nanosleep_nocancel <span class=o>()</span> from /lib64/libc.so.6
</span></span><span class=line><span class=cl>Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 libgcc-4.8.5-36.el7.x86_64 libstdc++-4.8.5-36.el7.x86_64
</span></span><span class=line><span class=cl><span class=o>(</span>gdb<span class=o>)</span> n
</span></span><span class=line><span class=cl>Single stepping <span class=k>until</span> <span class=nb>exit</span> from <span class=k>function</span> __nanosleep_nocancel,
</span></span><span class=line><span class=cl>which has no line number information.
</span></span><span class=line><span class=cl>0x00007ffff72b3cc4 in sleep <span class=o>()</span> from /lib64/libc.so.6
</span></span><span class=line><span class=cl><span class=o>(</span>gdb<span class=o>)</span> n
</span></span><span class=line><span class=cl>Single stepping <span class=k>until</span> <span class=nb>exit</span> from <span class=k>function</span> sleep,
</span></span><span class=line><span class=cl>which has no line number information.
</span></span><span class=line><span class=cl>main <span class=o>()</span> at test_process.cc:8
</span></span><span class=line><span class=cl>8       <span class=k>while</span><span class=o>(</span><span class=nv>num</span><span class=o>==</span>10<span class=o>){</span>
</span></span><span class=line><span class=cl><span class=o>(</span>gdb<span class=o>)</span> show follow-fork-mode
</span></span><span class=line><span class=cl>Debugger response to a program call of fork or vfork is <span class=s2>&#34;child&#34;</span>.
</span></span><span class=line><span class=cl><span class=o>(</span>gdb<span class=o>)</span>
</span></span></code></pre></div><p>在上述命令中，我们做了如下操作：</p><ol><li><p>show follow-fork-mode:通过该命令来查看当前处于什么模式下，通过输出可以看出，处于parent即父进程模式</p></li><li><p>set follow-fork-mode child:指定调试子进程模式</p></li><li><p>r:运行程序，直接运行程序，此时会进入子进程，然后执行while循环</p></li><li><p>ctrl + c:通过该命令，可以使得GDB收到SIGINT命令，从而暂停执行while循环</p></li><li><p>n(next):继续执行，进而进入到while循环的条件判断处</p></li><li><p>show follow-fork-mode:再次执行该命令，通过输出可以看出，当前处于child模式下</p></li></ol><h6 id=detach-on-fork>detach-on-fork<a hidden class=anchor aria-hidden=true href=#detach-on-fork>#</a></h6><p>如果一开始指定要调试子进程还是父进程，那么使用follow-fork-mode命令完全可以满足需求;但是如果想在调试过程中，想根据实际情况在父进程和子进程之间来回切换调试呢？</p><p>GDB提供了另外一个命令：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>(</span>gdb<span class=o>)</span> <span class=nb>set</span> detach-on-fork mode
</span></span></code></pre></div><p>其中mode有如下两个值：</p><p>on:默认值，即表明只调试一个进程，可以是子进程，也可以是父进程</p><p>off:程序中的每个进程都会被记录，进而我们可以对所有的进程进行调试</p><p>如果选择关闭<code>detach-on-fork</code>模式(mode为off)，那么GDB将保留对所有被fork出来的进程控制，即可用调试所有被fork出来的进程。可用 使用<code>info forks</code>命令列出所有的可被GDB调试的fork进程，并可用使用fork命令从一个fork进程切换到另一个fork进程。</p><ul><li><p>info forks: 打印DGB控制下的所有被fork出来的进程列表。该列表包括fork id、进程id和当前进程的位置</p></li><li><p>fork fork-id: 参数fork-id是GDB分配的内部fork编号，该编号可用通过上面的命令<code>info forks</code>获取</p></li></ul><h3 id=coredump>coredump<a hidden class=anchor aria-hidden=true href=#coredump>#</a></h3><p>当我们开发或者使用一个程序时候，最怕的莫过于程序莫名其妙崩溃。为了分析崩溃产生的原因，操作系统的内存内容（包括程序崩溃时候的堆栈等信息）会在程序崩溃的时候dump出来（默认情况下，这个文件名为core.pid，其中pid为进程id），这个dump操作叫做coredump(核心转储)，然后我们可以用调试器调试此文件，以还原程序崩溃时候的场景。</p><p>在我们分析如果用gdb调试coredump文件之前，先需要生成一个coredump，为了简单起见，我们就用如下例子来生成：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>print</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=n>v</span><span class=p>,</span> <span class=kt>int</span> <span class=n>size</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>size</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;elem[%d] = %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>v</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>v</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=nf>print</span><span class=p>(</span><span class=n>v</span><span class=p>,</span> <span class=mi>1000</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>编译并运行该程序：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>g++ -g test_core.cc -o test_core
</span></span><span class=line><span class=cl>./test_core
</span></span></code></pre></div><p>输出如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>elem<span class=o>[</span>775<span class=o>]</span> <span class=o>=</span> <span class=m>1702113070</span>
</span></span><span class=line><span class=cl>elem<span class=o>[</span>776<span class=o>]</span> <span class=o>=</span> <span class=m>1667200115</span>
</span></span><span class=line><span class=cl>elem<span class=o>[</span>777<span class=o>]</span> <span class=o>=</span> <span class=m>6648431</span>
</span></span><span class=line><span class=cl>elem<span class=o>[</span>778<span class=o>]</span> <span class=o>=</span> <span class=m>0</span>
</span></span><span class=line><span class=cl>elem<span class=o>[</span>779<span class=o>]</span> <span class=o>=</span> <span class=m>0</span>
</span></span><span class=line><span class=cl>段错误<span class=o>(</span>吐核<span class=o>)</span>
</span></span></code></pre></div><p>如我们预期，程序产生了异常，但是却没有生成coredump文件，这是因为在系统默认情况下，coredump生成是关闭的，所以需要设置对应的选项以打开coredump生成。</p><p>针对多线程程序产生的coredump，有时候其堆栈信息并不能完整的去分析原因，这就使得我们得有其他方式。</p><p>18年有一次线上故障，在测试环境一切正常，但是在线上的时候，就会coredump，根据gdb调试coredump，只能定位到了libcurl里面，但却定位不出原因，用了大概两天的时间，发现只有在超时的时候，才会coredump，而测试环境因为配置比较差超时设置的是20ms，而线上是5ms，知道coredump原因后，采用<code>逐步定位缩小范围法</code>，逐步缩小代码范围，最终定位到是libcurl一个bug导致。所以，很多时候，定位线上问题需要结合实际情况，采取合适的方法来定位问题。</p><h5 id=配置>配置<a hidden class=anchor aria-hidden=true href=#配置>#</a></h5><p>配置coredump生成，有临时配置(退出终端后，配置失效)和永久配置两种。</p><h6 id=临时>临时<a hidden class=anchor aria-hidden=true href=#临时>#</a></h6><p>通过ulimit -a<br>可以判断当前有没有配置coredump生成：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>ulimit</span> -a
</span></span><span class=line><span class=cl>core file size          <span class=o>(</span>blocks, -c<span class=o>)</span> <span class=m>0</span>
</span></span><span class=line><span class=cl>data seg size           <span class=o>(</span>kbytes, -d<span class=o>)</span> unlimited
</span></span><span class=line><span class=cl>scheduling priority             <span class=o>(</span>-e<span class=o>)</span> <span class=m>0</span>
</span></span></code></pre></div><p>从上面输出可以看出core file size后面的数为0，即不生成coredump文件，我们可以通过如下命令进行设置</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>ulimit -c size
</span></span></code></pre></div><p>其中size为允许生成的coredump大小，这个一般尽量设置大点，以防止生成的coredump信息不全，笔者一般设置为不限。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>ulimit -c unlimited
</span></span></code></pre></div><p>需要说明的是，临时配置的coredump选项，其默认生成路径为执行该命令时候的路径，可以通过修改配置来进行路径修改。</p><h6 id=永久>永久<a hidden class=anchor aria-hidden=true href=#永久>#</a></h6><p>上面的设置只是使能了core dump功能，缺省情况下，内核在coredump时所产生的core文件放在与该程序相同的目录中，并且文件名固定为core。很显然，如果有多个程序产生core文件，或者同一个程序多次崩溃，就会重复覆盖同一个core文件。</p><p>过修改kernel的参数，可以指定内核所生成的coredump文件的文件名。使用下面命令，可以实现coredump永久配置、存放路径以及生成coredump名称等。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>mkdir -p /www/coredump/
</span></span><span class=line><span class=cl>chmod 777 /www/coredump/
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/etc/profile
</span></span><span class=line><span class=cl><span class=nb>ulimit</span> -c unlimited
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/etc/security/limits.conf
</span></span><span class=line><span class=cl>*          soft     core   unlimited
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;/www/coredump/core-%e-%p-%h-%t&#34;</span> &gt; /proc/sys/kernel/core_pattern
</span></span></code></pre></div><h5 id=调试-1>调试<a hidden class=anchor aria-hidden=true href=#调试-1>#</a></h5><p>现在，我们重新执行如下命令，按照预期产生coredump文件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>./test_coredump
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>elem<span class=o>[</span>955<span class=o>]</span> <span class=o>=</span> <span class=m>1702113070</span>
</span></span><span class=line><span class=cl>elem<span class=o>[</span>956<span class=o>]</span> <span class=o>=</span> <span class=m>1667200115</span>
</span></span><span class=line><span class=cl>elem<span class=o>[</span>957<span class=o>]</span> <span class=o>=</span> <span class=m>6648431</span>
</span></span><span class=line><span class=cl>elem<span class=o>[</span>958<span class=o>]</span> <span class=o>=</span> <span class=m>0</span>
</span></span><span class=line><span class=cl>elem<span class=o>[</span>959<span class=o>]</span> <span class=o>=</span> <span class=m>0</span>
</span></span><span class=line><span class=cl>段错误<span class=o>(</span>吐核<span class=o>)</span>
</span></span></code></pre></div><p>然后使用下面的命令进行coredump调试：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>gdb ./test_core -c /www/coredump/core_test_core_1640765384_38924 -q
</span></span></code></pre></div><p>输出如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1>#0  0x0000000000400569 in print (v=0x7fff3293c100, size=1000) at test_core.cc:5</span>
</span></span><span class=line><span class=cl>5     printf<span class=o>(</span><span class=s2>&#34;elem[%d] = %d\n&#34;</span>, i, v<span class=o>[</span>i<span class=o>])</span><span class=p>;</span>
</span></span><span class=line><span class=cl>Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 libgcc-4.8.5-36.el7.x86_64 libstdc++-4.8.5-36.el7.x86_64
</span></span><span class=line><span class=cl><span class=o>(</span>gdb<span class=o>)</span>
</span></span></code></pre></div><p>可以看出，程序core在了第5行，此时，我们可以通过where命令来查看堆栈回溯信息。</p><blockquote><p>[!tip]
在gdb中输入where命令，可以获取堆栈调用信息。当进行coredump调试时候，这个是最基本且最有用处的命令。where命令输出的结果包含程序中 的函数名称和相关参数值。</p></blockquote><p>通过where命令，我们能够发现程序core在了第5行，那么根据分析源码基本就能定位原因。</p><blockquote><p>[!tip]
需要注意的是，在多线程运行的时候，core不一定在当前线程，这就需要我们对代码有一定的了解，能够保证哪块代码是安全的，然后通过thread num切换线程，然后再通过bt或者where命令查看堆栈信息，进而定位coredump原因。</p></blockquote><h2 id=原理>原理<a hidden class=anchor aria-hidden=true href=#原理>#</a></h2><p>在前面几节，我们讲了gdb的命令，以及这些命令在调试时候的作用，并以例子进行了演示。作为C/C++ coder，要知其然，更要知其所以然。所以，借助本节，我们大概讲下GDB调试的原理。</p><p>gdb通过系统调用<code>ptrace</code>来接管一个进程的执行。ptrace系统调用提供了一种方法使得父进程可以观察和控制其它进程的执行，检查和改变其核心映像以及寄存器。它主要用来实现断点调试和系统调用跟踪。</p><p><img alt=gdb-principle loading=lazy src=https://cdn.jsdelivr.net/gh/tianyuxbear/images/blog/gdb-principle.png></p><p>ptrace系统调用定义如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/ptrace.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>long</span> <span class=nf>ptrace</span><span class=p>(</span><span class=k>enum</span> <span class=n>__ptrace_request</span> <span class=n>request</span><span class=p>,</span> <span class=kt>pid_t</span> <span class=n>pid</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>addr</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>data</span><span class=p>)</span>
</span></span></code></pre></div><ul><li><p>pid_t pid：指示 ptrace 要跟踪的进程</p></li><li><p>void *addr：指示要监控的内存地址</p></li><li><p>enum __ptrace_request request：决定了系统调用的功能，几个主要的选项：</p><ul><li><p><code>PTRACE_TRACEME</code>：表示此进程将被父进程跟踪，任何信号（除了<code>SIGKILL</code>）都会暂停子进程，接着阻塞于<code>wait()</code>等待的父进程被唤醒。子进程内部对<code>exec()</code>的调用将发出<code>SIGTRAP</code> 信号，这可以让父进程在子进程新程序开始运行之前就完全控制它</p></li><li><p><code>PTRACE_ATTACH</code>：attach到一个指定的进程，使其成为当前进程跟踪的子进程，而子进程的行为等同于它进行了一次 PTRACE_TRACEME 操作。但需要注意的是，虽然当前进程成为被跟踪进程的父进程，但是子进程使用<code>getppid()</code>的到的仍将是其原始父进程的pid</p></li><li><p><code>PTRACE_CONT</code>：继续运行之前停止的子进程。可同时向子进程交付指定的信号</p></li></ul></li></ul><h3 id=调试原理>调试原理<a hidden class=anchor aria-hidden=true href=#调试原理>#</a></h3><h4 id=运行并调试新进程>运行并调试新进程<a hidden class=anchor aria-hidden=true href=#运行并调试新进程>#</a></h4><p>运行并调试新进程，步骤如下：</p><ul><li><p>运行gdb exe</p></li><li><p>输入run命令，gdb执行以下操作：</p><ul><li><p>通过fork()系统调用创建一个新进程</p></li><li><p>在新创建的子进程中执行ptrace(PTRACE_TRACEME, 0, 0, 0)操作</p></li><li><p>在子进程中通过execv()系统调用加载指定的可执行文件</p></li></ul></li></ul><h4 id=attach运行的进程>attach运行的进程<a hidden class=anchor aria-hidden=true href=#attach运行的进程>#</a></h4><p>可以通过gdb attach pid来调试一个运行的进程，gdb将对指定进程执行ptrace(PTRACE_ATTACH, pid, 0, 0)操作。</p><p>需要注意的是，当我们attach一个进程id时候，可能会报如下错误：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>Attaching to process <span class=m>28849</span>
</span></span><span class=line><span class=cl>ptrace: Operation not permitted.
</span></span></code></pre></div><p>这是因为没有权限进行操作，可以根据启动该进程用户下或者root下进行操作。</p><h3 id=断点原理>断点原理<a hidden class=anchor aria-hidden=true href=#断点原理>#</a></h3><h4 id=实现原理>实现原理<a hidden class=anchor aria-hidden=true href=#实现原理>#</a></h4><p>当我们通过b或者break设置断点时候，就是在指定位置插入断点指令，当被调试的程序运行到断点的时候，产生SIGTRAP信号。该信号被gdb捕获并 进行断点命中判断。</p><h4 id=设置原理>设置原理<a hidden class=anchor aria-hidden=true href=#设置原理>#</a></h4><p>在程序中设置断点，就是先在该位置保存原指令，然后在该位置写入int 3。当执行到int 3时，发生软中断，内核会向子进程发送SIGTRAP信号。当然，这个信号会转发给父进程。然后用保存的指令替换int 3并等待操作恢复。</p><h4 id=命中判断>命中判断<a hidden class=anchor aria-hidden=true href=#命中判断>#</a></h4><p>gdb将所有断点位置存储在一个<code>链表</code>中。命中判定将被调试程序的当前停止位置与链表中的断点位置进行比较，以查看断点产生的信号。</p><h4 id=条件判断>条件判断<a hidden class=anchor aria-hidden=true href=#条件判断>#</a></h4><p>在断点处恢复指令后，增加了一个条件判断。如果表达式为真，则触发断点。由于需要判断一次，添加条件断点后，是否触发条件断点，都会影响性能。在 x86 平台上，部分硬件支持硬件断点。不是在条件断点处插入 int 3，而是插入另一条指令。当程序到达这个地址时，不是发出int 3信号，而是进行比较。特定寄存器的内容和某个地址，然后决定是否发送int 3。因此，当你的断点位置被程序频繁“通过”时，尽量使用硬件断点，这将有助于提高性能。</p><h3 id=单步原理>单步原理<a hidden class=anchor aria-hidden=true href=#单步原理>#</a></h3><p>这个ptrace函数本身就支持，可以通过ptrace(PTRACE_SINGLESTEP, pid,&mldr;)调用来实现单步。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl> <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;attaching to PID %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>pid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>ptrace</span><span class=p>(</span><span class=n>PTRACE_ATTACH</span><span class=p>,</span> <span class=n>pid</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;attach failed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>waitStat</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>waitRes</span> <span class=o>=</span> <span class=nf>waitpid</span><span class=p>(</span><span class=n>pid</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>waitStat</span><span class=p>,</span> <span class=n>WUNTRACED</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>waitRes</span> <span class=o>!=</span> <span class=n>pid</span> <span class=o>||</span> <span class=o>!</span><span class=nf>WIFSTOPPED</span><span class=p>(</span><span class=n>waitStat</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;unexpected waitpid result!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>   
</span></span><span class=line><span class=cl>    <span class=kt>int64_t</span> <span class=n>numSteps</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=nb>true</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>auto</span> <span class=n>res</span> <span class=o>=</span> <span class=nf>ptrace</span><span class=p>(</span><span class=n>PTRACE_SINGLESTEP</span><span class=p>,</span> <span class=n>pid</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></div><p>上述代码，首先接收一个pid，然后对其进行attach，最后调用ptrace进行单步调试。</p><h2 id=其它-1>其它<a hidden class=anchor aria-hidden=true href=#其它-1>#</a></h2><p>借助本文，简单介绍下笔者工作过程中使用的一些其他命令或者工具。</p><h3 id=pstack>pstack<a hidden class=anchor aria-hidden=true href=#pstack>#</a></h3><p>此命令可显示每个进程的栈跟踪。pstack 命令必须由相应进程的属主或 root 运行。可以使用 pstack 来确定进程挂起的位置。此命令允许使用的唯一选项是要检查的进程的 PID。</p><p>这个命令在排查进程问题时非常有用，比如我们发现一个服务一直处于work状态（如假死状态，好似死循环），使用这个命令就能轻松定位问题所在；可以在一段时间内，多执行几次pstack，若发现代码栈总是停在同一个位置，那个位置就需要重点关注，很可能就是出问题的地方；</p><p>以前面的多线程代码为例，其进程ID是4507(在笔者本地)，那么通过</p><p>pstack 4507输出结果如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>Thread 3 <span class=o>(</span>Thread 0x7f07aaa69700 <span class=o>(</span>LWP 45708<span class=o>))</span>:
</span></span><span class=line><span class=cl><span class=c1>#0  0x00007f07aab2ee2d in nanosleep () from /lib64/libc.so.6#1  0x00007f07aab2ecc4 in sleep () from /lib64/libc.so.6#2  0x00007f07ab403eb9 in std::this_thread::__sleep_for(std::chrono::duration&lt;long, std::ratio&lt;1l, 1l&gt; &gt;, std::chrono::duration&lt;long, std::ratio&lt;1l, 1000000000l&gt; &gt;) () from /lib64/libstdc++.so.6#3  0x00000000004018cc in void std::this_thread::sleep_for&lt;long, std::ratio&lt;1l, 1l&gt; &gt;(std::chrono::duration&lt;long, std::ratio&lt;1l, 1l&gt; &gt; const&amp;) ()#4  0x00000000004012de in fun_int(int) ()#5  0x0000000000404696 in int std::_Bind_simple&lt;int (*(int))(int)&gt;::_M_invoke&lt;0ul&gt;(std::_Index_tuple&lt;0ul&gt;) ()#6  0x000000000040443d in std::_Bind_simple&lt;int (*(int))(int)&gt;::operator()() ()#7  0x000000000040436e in std::thread::_Impl&lt;std::_Bind_simple&lt;int (*(int))(int)&gt; &gt;::_M_run() ()#8  0x00007f07ab404070 in ?? () from /lib64/libstdc++.so.6#9  0x00007f07ab65ddd5 in start_thread () from /lib64/libpthread.so.0#10 0x00007f07aab67ead in clone () from /lib64/libc.so.6Thread 2 (Thread 0x7f07aa268700 (LWP 45709)):#0  0x00007f07aab2ee2d in nanosleep () from /lib64/libc.so.6#1  0x00007f07aab2ecc4 in sleep () from /lib64/libc.so.6#2  0x00007f07ab403eb9 in std::this_thread::__sleep_for(std::chrono::duration&lt;long, std::ratio&lt;1l, 1l&gt; &gt;, std::chrono::duration&lt;long, std::ratio&lt;1l, 1000000000l&gt; &gt;) () from /lib64/libstdc++.so.6#3  0x00000000004018cc in void std::this_thread::sleep_for&lt;long, std::ratio&lt;1l, 1l&gt; &gt;(std::chrono::duration&lt;long, std::ratio&lt;1l, 1l&gt; &gt; const&amp;) ()#4  0x0000000000401340 in fun_string(std::string const&amp;) ()#5  0x000000000040459f in int std::_Bind_simple&lt;int (*(char const*))(std::string const&amp;)&gt;::_M_invoke&lt;0ul&gt;(std::_Index_tuple&lt;0ul&gt;) ()#6  0x000000000040441f in std::_Bind_simple&lt;int (*(char const*))(std::string const&amp;)&gt;::operator()() ()#7  0x0000000000404350 in std::thread::_Impl&lt;std::_Bind_simple&lt;int (*(char const*))(std::string const&amp;)&gt; &gt;::_M_run() ()#8  0x00007f07ab404070 in ?? () from /lib64/libstdc++.so.6#9  0x00007f07ab65ddd5 in start_thread () from /lib64/libpthread.so.0#10 0x00007f07aab67ead in clone () from /lib64/libc.so.6Thread 1 (Thread 0x7f07aba80740 (LWP 45707)):#0  0x00007f07ab65ef47 in pthread_join () from /lib64/libpthread.so.0#1  0x00007f07ab403e37 in std::thread::join() () from /lib64/libstdc++.so.6#2  0x0000000000401455 in main ()</span>
</span></span></code></pre></div><p>在上述输出结果中，将进程内部的详细信息都输出在终端，以方便分析问题。</p><h3 id=ldd>ldd<a hidden class=anchor aria-hidden=true href=#ldd>#</a></h3><p>在我们编译过程中通常会提示编译失败，通过输出错误信息发现是找不到函数定义，再或者编译成功了，但是运行时候失败(往往是因为依赖了非正常版本的lib库导致)，这个时候，我们就可以通过ldd来分析该可执行文件依赖了哪些库以及这些库所在的路径。</p><p>用来查看程式运行所需的共享库,常用来解决程式因缺少某个库文件而不能运行的一些问题。</p><p>仍然查看可执行程序test_thread的依赖库，输出如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>ldd -r ./test_thread
</span></span><span class=line><span class=cl> linux-vdso.so.1 <span class=o>=</span>&gt;  <span class=o>(</span>0x00007ffde43bc000<span class=o>)</span>
</span></span><span class=line><span class=cl> libpthread.so.0 <span class=o>=</span>&gt; /lib64/libpthread.so.0 <span class=o>(</span>0x00007f8c5e310000<span class=o>)</span>
</span></span><span class=line><span class=cl> libstdc++.so.6 <span class=o>=</span>&gt; /lib64/libstdc++.so.6 <span class=o>(</span>0x00007f8c5e009000<span class=o>)</span>
</span></span><span class=line><span class=cl> libm.so.6 <span class=o>=</span>&gt; /lib64/libm.so.6 <span class=o>(</span>0x00007f8c5dd07000<span class=o>)</span>
</span></span><span class=line><span class=cl> libgcc_s.so.1 <span class=o>=</span>&gt; /lib64/libgcc_s.so.1 <span class=o>(</span>0x00007f8c5daf1000<span class=o>)</span>
</span></span><span class=line><span class=cl> libc.so.6 <span class=o>=</span>&gt; /lib64/libc.so.6 <span class=o>(</span>0x00007f8c5d724000<span class=o>)</span>
</span></span><span class=line><span class=cl> /lib64/ld-linux-x86-64.so.2 <span class=o>(</span>0x00007f8c5e52c000<span class=o>)</span>
</span></span></code></pre></div><p>在上述输出中：</p><ul><li><p>第一列：程序需要依赖什么库</p></li><li><p>第二列：系统提供的与程序需要的库所对应的库</p></li><li><p>第三列：库加载的开始地址</p></li></ul><p>在有时候，我们通过ldd查看依赖库的时候，会提示找不到库，如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>ldd -r test_process
</span></span><span class=line><span class=cl> linux-vdso.so.1 <span class=o>=</span>&gt;  <span class=o>(</span>0x00007ffc71b80000<span class=o>)</span>
</span></span><span class=line><span class=cl> libstdc++.so.6 <span class=o>=</span>&gt; /lib64/libstdc++.so.6 <span class=o>(</span>0x00007fe4badd5000<span class=o>)</span>
</span></span><span class=line><span class=cl> libm.so.6 <span class=o>=</span>&gt; /lib64/libm.so.6 <span class=o>(</span>0x00007fe4baad3000<span class=o>)</span>
</span></span><span class=line><span class=cl> libgcc_s.so.1 <span class=o>=</span>&gt; /lib64/libgcc_s.so.1 <span class=o>(</span>0x00007fe4ba8bd000<span class=o>)</span>
</span></span><span class=line><span class=cl> libc.so.6 <span class=o>=</span>&gt; /lib64/libc.so.6 <span class=o>(</span>0x00007fe4ba4f0000<span class=o>)</span>
</span></span><span class=line><span class=cl> /lib64/ld-linux-x86-64.so.2 <span class=o>(</span>0x00007fe4bb0dc000<span class=o>)</span>
</span></span><span class=line><span class=cl>  liba.so <span class=o>=</span>&gt; not found
</span></span></code></pre></div><p>比如上面最后一句提示，liba.so找不到，这个时候，需要我们知道liba.so的路径，比如在/path/to/liba.so，那么可以有下面两种方式：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nv>LD_LIBRARY_PATH</span><span class=o>=</span><span class=nv>$LD_LIBRARY_PATH</span>:/path/to/
</span></span></code></pre></div><p>这样在通过ldd查看，就能找到对应的lib库，但是这个缺点是临时的，即退出终端后，再执行ldd，仍然会提示找不到该库，所以就有了另外一种方式，即通过修改/etc/ld.so.conf，在该文件的后面加上需要的路径，即</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>include ld.so.conf.d/*.conf
</span></span><span class=line><span class=cl>/path/to/
</span></span></code></pre></div><p>然后通过如下命令，即可永久生效</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl> /sbin/ldconfig
</span></span></code></pre></div><h3 id=cfilt>c++filt<a hidden class=anchor aria-hidden=true href=#cfilt>#</a></h3><p>因为c++支持重载，也就引出了编译器的<code>name mangling</code>机制，对函数进行重命名。</p><p>我们通过strings命令查看test_thread中的函数信息(仅输出fun等相关)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>strings test_thread <span class=p>|</span> grep fun_
</span></span><span class=line><span class=cl>in fun_int <span class=nv>n</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>in fun_string <span class=nv>s</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>_GLOBAL__sub_I__Z7fun_inti
</span></span><span class=line><span class=cl>_Z10fun_stringRKSs
</span></span></code></pre></div><p>可以看到_Z10fun_stringRKSs这个函数，如果想知道这个函数定义的话，可以使用c++filt命令，如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl> <span class=n>c</span><span class=o>++</span><span class=n>filt</span> <span class=nf>_Z10fun_stringRKSsfun_string</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>basic_string</span><span class=o>&lt;</span><span class=kt>char</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>char_traits</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>&gt;</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>allocator</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>&gt;</span> <span class=o>&gt;</span> <span class=k>const</span><span class=o>&amp;</span><span class=p>)</span>
</span></span></code></pre></div><p>通过上述输出，我们可以将编译器生成的函数名还原到我们代码中的函数名即fun_string。</p><h2 id=结语>结语<a hidden class=anchor aria-hidden=true href=#结语>#</a></h2><p>GDB是一个在Linux上进行开发的一个必不可少的调试工具，使用场景依赖于具体的需求或者遇到的具体问题。在我们的日常开发工作中，熟练使用GDB加以辅助，能够使得开发过程事半功倍。</p><p>本文从一些简单的命令出发，通过举例调试可执行程序(单线程、多线程以及多进程场景)、coredump文件等各个场景，使得大家能够更加直观的了解GDB的使用。GDB功能非常强大，笔者工作中使用的都是非常基本的一些功能，如果想深入理解GDB，则需要去官网进行阅读了解。</p><blockquote><p>[!tip]<br>本文从构思到完成，大概用了三周时间，写作过程是痛苦的(需要整理资料以及构建各种场景，以及将各种现场还原)，同时又是收获满满的。通过本文，进一步加深了对GDB的底层原理理解。</p></blockquote><h2 id=参考>参考<a hidden class=anchor aria-hidden=true href=#参考>#</a></h2><p><a href=https://www.codetd.com/en/article/13107993>https://www.codetd.com/en/article/13107993</a></p><p><a href=https://www.codetd.com/en/article/13107993https://users.ece.utexas.edu/~adnan/gdb-refcard.pdf>https://www.codetd.com/en/article/13107993https://users.ece.utexas.edu/~adnan/gdb-refcard.pdf</a> </p><p><a href=https://www.cloudsavvyit.com/10921/debugging-with-gdb-getting-started/>https://www.cloudsavvyit.com/10921/debugging-with-gdb-getting-started/</a> </p><p><a href="https://blog.birost.com/a?ID=00650-b03e2257-94bf-41f3-b0fc-d352d5b02431">https://blog.birost.com/a?ID=00650-b03e2257-94bf-41f3-b0fc-d352d5b02431</a> </p><p><a href=https://www.cnblogs.com/xsln/p/ptrace.html>https://www.cnblogs.com/xsln/p/ptrace.html</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://codebearjourney.top/tags/gdb/>GDB</a></li><li><a href=https://codebearjourney.top/tags/%E8%B0%83%E8%AF%95/>调试</a></li><li><a href=https://codebearjourney.top/tags/linux/>Linux</a></li><li><a href=https://codebearjourney.top/tags/c++/>C++</a></li><li><a href=https://codebearjourney.top/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/>开发工具</a></li></ul><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share GDB调试: 从入门实践到原理 on x" href="https://x.com/intent/tweet/?text=GDB%e8%b0%83%e8%af%95%3a%20%e4%bb%8e%e5%85%a5%e9%97%a8%e5%ae%9e%e8%b7%b5%e5%88%b0%e5%8e%9f%e7%90%86&amp;url=https%3a%2f%2fcodebearjourney.top%2fposts%2fgdb%25E8%25B0%2583%25E8%25AF%2595-%25E4%25BB%258E%25E5%2585%25A5%25E9%2597%25A8%25E5%25AE%259E%25E8%25B7%25B5%25E5%2588%25B0%25E5%258E%259F%25E7%2590%2586%2f&amp;hashtags=GDB%2c%e8%b0%83%e8%af%95%2cLinux%2cC%2b%2b%2c%e5%bc%80%e5%8f%91%e5%b7%a5%e5%85%b7"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share GDB调试: 从入门实践到原理 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fcodebearjourney.top%2fposts%2fgdb%25E8%25B0%2583%25E8%25AF%2595-%25E4%25BB%258E%25E5%2585%25A5%25E9%2597%25A8%25E5%25AE%259E%25E8%25B7%25B5%25E5%2588%25B0%25E5%258E%259F%25E7%2590%2586%2f&amp;title=GDB%e8%b0%83%e8%af%95%3a%20%e4%bb%8e%e5%85%a5%e9%97%a8%e5%ae%9e%e8%b7%b5%e5%88%b0%e5%8e%9f%e7%90%86&amp;summary=GDB%e8%b0%83%e8%af%95%3a%20%e4%bb%8e%e5%85%a5%e9%97%a8%e5%ae%9e%e8%b7%b5%e5%88%b0%e5%8e%9f%e7%90%86&amp;source=https%3a%2f%2fcodebearjourney.top%2fposts%2fgdb%25E8%25B0%2583%25E8%25AF%2595-%25E4%25BB%258E%25E5%2585%25A5%25E9%2597%25A8%25E5%25AE%259E%25E8%25B7%25B5%25E5%2588%25B0%25E5%258E%259F%25E7%2590%2586%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share GDB调试: 从入门实践到原理 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fcodebearjourney.top%2fposts%2fgdb%25E8%25B0%2583%25E8%25AF%2595-%25E4%25BB%258E%25E5%2585%25A5%25E9%2597%25A8%25E5%25AE%259E%25E8%25B7%25B5%25E5%2588%25B0%25E5%258E%259F%25E7%2590%2586%2f&title=GDB%e8%b0%83%e8%af%95%3a%20%e4%bb%8e%e5%85%a5%e9%97%a8%e5%ae%9e%e8%b7%b5%e5%88%b0%e5%8e%9f%e7%90%86"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share GDB调试: 从入门实践到原理 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fcodebearjourney.top%2fposts%2fgdb%25E8%25B0%2583%25E8%25AF%2595-%25E4%25BB%258E%25E5%2585%25A5%25E9%2597%25A8%25E5%25AE%259E%25E8%25B7%25B5%25E5%2588%25B0%25E5%258E%259F%25E7%2590%2586%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share GDB调试: 从入门实践到原理 on whatsapp" href="https://api.whatsapp.com/send?text=GDB%e8%b0%83%e8%af%95%3a%20%e4%bb%8e%e5%85%a5%e9%97%a8%e5%ae%9e%e8%b7%b5%e5%88%b0%e5%8e%9f%e7%90%86%20-%20https%3a%2f%2fcodebearjourney.top%2fposts%2fgdb%25E8%25B0%2583%25E8%25AF%2595-%25E4%25BB%258E%25E5%2585%25A5%25E9%2597%25A8%25E5%25AE%259E%25E8%25B7%25B5%25E5%2588%25B0%25E5%258E%259F%25E7%2590%2586%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share GDB调试: 从入门实践到原理 on telegram" href="https://telegram.me/share/url?text=GDB%e8%b0%83%e8%af%95%3a%20%e4%bb%8e%e5%85%a5%e9%97%a8%e5%ae%9e%e8%b7%b5%e5%88%b0%e5%8e%9f%e7%90%86&amp;url=https%3a%2f%2fcodebearjourney.top%2fposts%2fgdb%25E8%25B0%2583%25E8%25AF%2595-%25E4%25BB%258E%25E5%2585%25A5%25E9%2597%25A8%25E5%25AE%259E%25E8%25B7%25B5%25E5%2588%25B0%25E5%258E%259F%25E7%2590%2586%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share GDB调试: 从入门实践到原理 on ycombinator" href="https://news.ycombinator.com/submitlink?t=GDB%e8%b0%83%e8%af%95%3a%20%e4%bb%8e%e5%85%a5%e9%97%a8%e5%ae%9e%e8%b7%b5%e5%88%b0%e5%8e%9f%e7%90%86&u=https%3a%2f%2fcodebearjourney.top%2fposts%2fgdb%25E8%25B0%2583%25E8%25AF%2595-%25E4%25BB%258E%25E5%2585%25A5%25E9%2597%25A8%25E5%25AE%259E%25E8%25B7%25B5%25E5%2588%25B0%25E5%258E%259F%25E7%2590%2586%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><span class=topInner><svg class="topSvg" viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
<span id=read_progress></span>
</span></a><script>document.addEventListener("scroll",function(){const t=document.getElementById("read_progress"),n=document.documentElement.scrollHeight,s=document.documentElement.clientHeight,o=document.documentElement.scrollTop||document.body.scrollTop;t.innerText=((o/(n-s)).toFixed(2)*100).toFixed(0)})</script></body></html>